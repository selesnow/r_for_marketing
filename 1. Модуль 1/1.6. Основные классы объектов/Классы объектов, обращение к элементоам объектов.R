# Основные классы объктов

################################################################
################################################################

## Вектор ====
### Создание вектора
names <- c("Алексей", "Денис", "Николай", "Виктор", "Денис") # создание тектового вектора
country <- c("RU", "UA", "KZ", "BY", "BG", "BR", "TR", "US", "CA")

age <- c(34, 25, 39, 30, 28)                        # создание числового вектора
nums <- 5:20                                        # создание вектора из простой последовательсти чисел
nums <- seq(from = 5, to = 20)
nums_2 <- seq(from = 5, to = 20, by = 2)            # создание вектора из последовательности чисел с определённым шагом
nums_3 <- seq(from = 5, to = 20, length.out = 9)    # создание последновательсти чисел определённой длинны

name_vector <- c(name = "Алексей", age = 34, company = "Netpeak") # создание вектора с именоваными элементами

## Обращение к элементам вектора
names[2]                           # значение по его индексу
names[-4]                          # исключить значения по индексу
names[c(2,4)]                      # нескоько значений по индексам
names[c(TRUE, TRUE, FALSE, TRUE)]  # с помощью логического TRUE / FALSE
name_vector["company"]             # зачение по его имени
age[ age > 31 ]                    # через логическое выражение
which(age > 31)                    # получить индексы элементов по логическому выражению

## манипуляция с элементами вектора
sort(country)                      # сортировка элементов вектора по возрастанию
sort(country, decreasing = TRUE)   # сортировка элементов вектора по убыванию
unique(names)                      # получить список уникальных элементов вектора

sample(x       = country,          # выборка случайных элементов из вектора
       size    = 8,
       replace = F)                # replace управляет возможность повтора элементов

c(age, nums)                       # объеденение двух векторов

## Логические операция с элементами векторов
vec1 <- c(5, 8, 1, 9)
vec2 <- c(5, 2, 10)

vec1 > vec2

vec1 > 3 & vec1 < 9  # пример логического и
vec1 < 8 | vec1 > 8  # пример логического или

vec1 > 3 && vec1 < 9 # пример использования невекторизированного оператора И

## свойства вектора
length(names)       # получить количество элементов
names(name_vector)  # получить имена элементов

## Свойства вектора
class(nums_3)       # получить тип данных
class(age)

################################################################
################################################################

# DataFrame (Таблица)
## Пример создание таблицы пользователей
users <- data.frame(Names      = names,
                    Age        = age,
                    Country_id = sample(1:length(country),
                                        size = length(names),
                                        replace = T),
                    Id         = 1:length(names))

#### Создаём таблицу - справочник стран
country_dicy <- data.frame(id           = 1:length(country),
                           country_name = sort(country))

## Обращение к элементам таблицы
users[3, ]                    # получить 3 строку
users[2:4, ]                  # получить 2-4 строку по номеру
users[, 2]                    # получить 2 столбец
users[["Age"]]                # получить столбец по имени
users$Age                     # получить столбец по имени
users[, c("Names", "Id")]     # получить несколько столбцов по имени
users[, c(2, 3)]              # получить несколько столбцов по номерам

users[ users$Age > 30, ]      # получить строки по логическому выражению
users$Names[ users$Age > 30 ] # получить значения одного поля, по лог выражению другого поля

head(users, n = 3)            # получить верхние 3 строки таблицы
tail(users, n = 3)            # получить нижние три строки таблицы

## Сортировка таблиц
users[ order( users$Age, decreasing = T), ]

## Структура таблицы и описательные статистики
str(users)        # структура таблицы
summary(users)    # описательные таблицы

## Создание поднаборов
### Выбираем поднабор состоящий из пользователей от 30 лет и старше
users_after_30 <- subset(x = users, Age >= 30, select = c(Id, Names))
### Выбираем пользователейв имени которых присутвует буква "к" и количество букв в имени более 5
users_i        <- subset(x = users,
                         grepl(x = users$Names, pattern = "к") & nchar(as.character(users$Names)) > 5,
                         select = c(Id, Names))

## Объединение таблиц
users_two      <- rbind(users_after_30, users_i) # объединения таблиц по строкам
users_three    <- cbind(users_after_30 ,users_i) # объединение таблиц по столбцам

### Объединение таблиц по ключу
#### Соединяем таблицу пользователей со справочником по id страны
user_resul <- merge(x = users,           # левая таблица
                    y = country_dicy,    # правая таблица
                    by.x = "Country_id", # имя поля ключа в левой таблице
                    by.y = "id",         # имя поля ключа в правой таблице
                    all.x = TRUE)        # тип соединения, в данном случае левое соединение

################################################################
################################################################

# List (Список)
my_list <- list(user = list(id = 1,
                            name = "Alex",
                            data = users[ users$Id == 1, ] ))

my_list_2 <- list(users, age, names, name_vector)

# Обращение к элементам списка
my_list$user$data$Names

my_list_2[[4]]
my_list_2[[4]][[2]]
my_list_2[[4]][["company"]]

# Проверить класс объекта
class(users)
class(age)
class(my_list)
