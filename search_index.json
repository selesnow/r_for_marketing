[
["index.html", "Язык R в интернет маркетинге 1 Описание", " Язык R в интернет маркетинге Алексей Селезнёв 2018-11-01 1 Описание Данная методичка представляет из себя краткий конспект курса “Язык R в интернет маркетинга”, и поможет студентам в поиске нужных материалов по завершению курса для решения своих повседневных задач. Полное копирование материалов данного конспекта запрещено, частичное копирование конспекта возможно, но требует согласование с автором (selesnow@gmail.com), и обязательную ссылку на оригинал коспекта. "],
["a-.html", "2 a - О курсе 2.1 Для кого этот курс 2.2 Какие знания требуются для прохождения курса 2.3 Какие темы не будут затронуты в ходе курса 2.4 Что вы будете уметь поосле проождения курса 2.5 Поддержка студентов 2.6 Конспект курса 2.7 Программа курса", " 2 a - О курсе 2.1 Для кого этот курс Целевая аудитория курса интернет маркетологи и веб-аалитики, которые ежедневно работают с такими сервисами как Яндекс Директ, Google Ads, Google Analytics, Яндекс Метрика и т.д. 2.2 Какие знания требуются для прохождения курса Для прохождения курса “Язык R для интернет маркетинга” требуется только понимаение предметной области интернет маркетинга и веб аналитики, т.е. знание интерфейса рекламных и веб-аналитических сервисов, понимания структуры и объектов рекламных аккаунтов. 2.3 Какие темы не будут затронуты в ходе курса Как я уже писал выше для прохождения курса требуется понимание предметной области т.к. мы не будем рассматривать такие темы как: “Что такое веб аналитика”, “Что такое контекстная реклама”, “Как настраивать рекламные кампании”, “Основы SEO продвижения”. Так же мы не будем говорить о статистике и о построение моделей машинного обучения, данный курс сфокусирован на пцессе автоматизации рутинных задач интернет маркетологов и веб - аналитиков. Мы будем работать с различными базами данных, но при этом отдельно изучать язык запросов т.е. SQL не будем, но вы можете найти довольно большое количество бесплатных онлайн курсов для изучения этого языка. 2.4 Что вы будете уметь поосле проождения курса Курс состоит из трёх модулей. 1. Основы программирования на языке R. 2. Сбор данных из API рекламных плозадок и платформ веб аналитики. 3. Использование собранных данных. Соответвенно по окончанию курса вы получите следующие навыки: Иметь навыки программирования на языке R и познакомитесь с самыми популярными пакетами расширяющими базовые возможности языка. Собирать данные из API всех популярных рекламных площадок и систем веб аналитики. Использоват собранные данные, отправиь электронные письма, работат с базами данных, настраивать запуск скриптов по расспсианию. 2.5 Поддержка студентов Свои вопросы по материалам курса вы можете задавать с помощью комментариев к урокам, таким образом другие студенты у которых возник такой же вопрос смогут быстро найти информацию. 2.6 Конспект курса Сейчас вы читаете конспект к курсу, данный конспект находится в свободном доступе, периодически консепкт будет актуализироваться и дорабатываться, дату последней редакции конспекта вы видите на главной странице и в этом блоке. Наиболее актуальная редакция конспекта на данный момент - 2018-11-01 2.7 Программа курса Модуль 1: Введение в R. История, возможности, преимущества и недостатки языка R. Загрузка и установка языка R и среды разработки RStudio. Области применения R скриптов в Power BI. Знакомство со средой разработки RStudio. Основные классы объектов в R Векторы в R, что такое вектор, как обращаться к элементам вектора, основные типы данных в R. Data frame, основной класс объектов в R, как выбирать столбцы, строки, проводить расчёты. List - Списки. Работа со строками в R. Манипуляция с данными в R, пакеты dplyr, data.table, tidyr, sqldf. Работа с датами и временем в R, пакет lubridate. Условные конструкции, Циклы и функции в R. Рекомендации по оформлению кода и обработка ошибок. Модуль 2: Загрузка данных в Power BI, из API рекламных площадок и парсинг веб сайтов с помощью языка R. Что такое API. Загрузка данных из Google AdWords. Как получить доступ к API Google AdWords. Введение в API AdWords. Как получить данные из API Google AdWords с помощью пакета RAdwords. Как получить данные из API Google AdWords в Power BI с помощью коннектора “R скрипт”. Загрузка данных из Яндекс Директ. Введение в сервис Reports. Как получить данные из API Яндекс Директ с помощью пакета ryandexdirect. Как получить данные из API Яндекс Директ в Power BI с помощью коннектора “R скрипт”. Загрузка данных из Facebook. Как получить доступ к API Facebook. Введение в API Facebook. Как получить данные о рекламных кампаниях из API Facebook с помощью пакета rfacebookstat, Как получить данные из API Facebook в Power BI с помощью коннектора “R скрипт”. Загрузка данных из Вконтакте. Как получить доступ к API Вконтакте. Как получить данные из API Вконтакте с помощью пакета rvkstat. Как получить данные из API Вконтакте в Power BI с помощью коннектора “R скрипт”. Загрузка данных из MyTarget. Как получить данные из API MyTarget с помощью пакета rmytarget. Как получить данные из API MyTarget в Power BI с помощью коннектора “R скрипт”. Загрузка данных из Google Analytics. Введение в API Google Analytics. Как получить данные из Core API Google Analytics с помощью пакета RGA. Как получить данные из Multi-Channel Funnels Reporting API с помощью пакета RGA. Как получить данные из Real Time Reporting API с помощью пакета RGA. Как получить данные из API Google Analytics в Power BI с помощью коннектора “R скрипт”. Загрузка данных из API Яндекс Метрики. Пакет rym API управления Яндекс Метрики API отчётов Яндекс Метрики Logs API Яндекс Метрики API Яндекс Метрики совместимый с Core API Google Analytics v3 Загрузка данных из API Яндекс Метрики в Power BI с помощью коннектора “R скрипт”. Загрузка данных из Google SearchConsole и Google Trends. Парсинг сайтов с помощью пакета rvest. Отправка HTTP запросов из R, пакет httr. Модуль 3: Работа с данными загруженными из API рекламных систем и парсинга сайтов. Работа с Google Таблицами из R. Визуализация данных с помощью пакета ggplot2. Отправка и чтение данных из СУБД (MySQL, PostgreSQL, SQLite, Google BigQuery). Отправка почты с помощью пакета mailR. Настройка запуска скриптов по расписанию, пакет taskscheduleR. "],
["b-.html", "3 b - Об авторе", " 3 b - Об авторе На данный момент занимает должность руководителя отдела аналитики в Netpeak. В 2006 году закончил факультет “”Эконономики бизнеса и менеджмента“” Одесской Национальной Академии Пищевых Технологий им. М.В.Ломоносава по специальности “”Учёт и аудит“”. С 2008 по 2012 год работал в компании Цитрус, которая занимает лидирующие позиции на рынке гаджетов и аксессуаров Украины, пройдя путь от аудитора до начальника отдела аналитики. В интернет маркетинг пришел в 2012 году, работая в аналитическом отделе сервиса онлайн бронирования авиа билетов Senturia, который в 2013 году вошел в топ 10 e-commerce проектов UAнета по версии Forbes. В компании занимался построением автомаизацией аналитических процессов, алгоритмов обработки больших объёмов информации и построением визуализации данных. В 2014 году пришел в Netpeak в должности аналитика по контекстной рекламе, с 2016 года занимается развитием аналитики как внутри компании так и разработкой аналитических решений для клиентов Netpeak. Является автором пакетов расширяющих базовые возможности языка R и позволяющих автоматизировать рутинные операции при работе с такими системами как Яндекс Директ, Яндекс Метрика, Facebook, Вконтакте и MyTArget. Многие из разработанных пакетов были загружены в основной репозиторий хранения пакетов для R - CRAN. За время своей карьеры благодаря большому интересу к построению алгоритмов обработки и визуализации данных, а так же своей гиковости изучил множество методов и инструментов направленных на работу с данными, накопленными знаниями регулярно делится в своих публикациях на блоге Netpeak и других интернет изданиях. Алексей Селезнёв "],
["c-.html", "4 c - Благодарности", " 4 c - Благодарности Запись курса весьма трудоёмкий и сложный процесс, и сделать всё самому мне было бы довольно сложно, поэтому хочу выразить благодарность всем, кто тем или инным образом участвовал в создании курса: Компанию Netpeak, которая обеспечила всё техническое оснащение которое требовалось для записи видео уроков, а так же отдельно хочу поблагодарить Романа Ефрёменко и Анну Знамеровскую за помощь в ходе записи видео уроков, Валерия Красько за то, что согласился отложить большой объём срочных задач и тем самым освободил время необходимое на запись данного курса. Максиму Уварову за то, что предложил записать данный курс. Александре Скрастынь за видео монтаж всех уроков. "],
["-1-r-.html", "5 Модуль 1: Введение в R. 5.1 История создания языка R 5.2 Преимущества языка R. 5.3 Установка языка R и среды разработки RStudio 5.4 Загрузка, преобразование и визуализация данных в Power BI с помощью R скриптов. 5.5 Среда разработки RStudio 5.6 Классы объектов в языке R 5.7 Работа со строками на языке R 5.8 Загрузка данных из csv, excel и json файлов в R 5.9 Агрегирующие функции и арифметические операции в R 5.10 Манипуляция с данными, (группировка и агреция). 5.11 Работа с датами и временем в R, пакет lubridate. 5.12 Условные конструкции if, ifelse, switch в R 5.13 Циклы for и while 5.14 Разработка собственных функций в языке R 5.15 Обработка ошибок в R, функция try 5.16 Рекомендации по оформлению кода для упрощения его читаемости", " 5 Модуль 1: Введение в R. Первый модуль курса посвящён введению в язык R, в ходе модуля рассматривается следующие темы: История, возможности, преимущества и недостатки языка R. Загрузка и установка языка R и среды разработки RStudio. Области применения R скриптов в Power BI. Знакомство со средой разработки RStudio. Основные классы объектов в R Векторы в R, что такое вектор, как обращаться к элементам вектора, основные типы данных в R. Data frame, основной класс объектов в R, как выбирать столбцы, строки, проводить расчёты. List - Списки. R пакеты. Как упростить и ускорить работу с таблицами с помощью пакета data.table. Манипуляция с данными с помощью пакета dplyr. Преобразование данных с помощью пакета tidyr. Циклы в R (for и while), синтаксис, пример использования. 5.1 История создания языка R Язык R был разработан в 1993 году сотрудниками статистического факультета Оклендского университета Россом Айхэкой (англ. Ross Ihaka) и Робертом Джентлменом (англ. Robert Gentleman) (первая буква их имён — R), для для статистической обработки данных и работы с графикой. Долгие годы R использовался исключительно в исследовательских институтах для статического анализа данных, в бизнес и маркетинг этот язык просочился уже ближе к 2010 году. Именно в 2010 году R вошёл в список победителей конкурса журнала Infoworld[en] в номинации на лучшее открытое программное обеспечение для разработки приложений. 5.2 Преимущества языка R. R является Свободным программным обеспечением. R — это очень общий пакет статистического анализа, включает длинный список функций и пакетов, написанных пользователями. Смотрите: CRAN Contributed packages(англ.). R доступен для всех операционных систем, включая Linux, Mac OS, Windows. R включает самые последние методики. R — объектно ориентированный. Теоретически, всё что угодно может быть сохранено как объект R. Для пользователей умеющих писать более не менее сложные формулы в Ecxel перейти в R будет первое время непривычно но не сложно. Язык R предоставляет пользователю практически неограниченные возможности для визуализации данных. Поскольку R является любимым языком профессиональных статистиков, все последние достижения статистической науки очень быстро становятся доступными для пользователей R во всем мире в виде дополнительных библиотек. Ни одна коммерческая система статистического анализа так быстро сегодня не развивается. 5.3 Установка языка R и среды разработки RStudio Процесс установки языка R и RStudio достаточно прост и не требует никаких дополнительных манипуляций, нет никакой необходимости менять какие либо настройки в мастере установки. 5.3.1 Ссылки для загрузки R и RStudio R для Windows - https://cran.r-project.org/bin/windows/base/ RStudio - https://www.rstudio.com/products/rstudio/download/ 5.4 Загрузка, преобразование и визуализация данных в Power BI с помощью R скриптов. 5.4.1 Загрузка данных в Power BI. Для загрузки данных с применением R скриптов перейдите в Power BI в диалоговое окно “Получить данные”, перейдите в группу “Другое”, выберите из доступных коннекторов “R-скрипт” и нажмите кнопку “Подключится”. Окно “Получить данные” в Power BI После чего попав в диалоговое окно “R-скрипт” введите следующий код для загрузки данных из csv файла, при использовании приведённого ниже кода необходимо прописать путь к файлу name_values.csv, там куда вы распаковали материали курса: # Загрузка таблицы данных my_data &lt;- read.table(file = &quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 3/name_values.csv&quot;, sep = &quot;;&quot;, header = TRUE) Загрузка данных в Power BI Помните что обратный слеш (\\) в R используется для экранирования символов, поэтому при прописывании пути к файлу необходимо использовать либо прямой слэш (/), либо двойной обратный слэш (\\\\). 5.4.2 Преобразование данных в Power BI (power query). Задача: Необходимо обезличить данные, загруженные на прошлом шаге, в загруженной таблице есть 3 поля: ID, Name, Value, задача заключается в том, что бы заменить все имена на user_номер пользователя. Для решения задачи нам необходимо перейти в редактор запросов, далее перейти на вкладку “Преобразование”, и ажать кнопку “Запустить сценарий R”: Далее в окне “Запустить сценарий R” воспроизвести следующий код: # &#39;dataset&#39; содержит входные данные для этого сценария # Копируем входящие данные в дата фрейм my_data my_data &lt;- dataset # Создаём таблицу Id пользователей user_id &lt;- data.frame(Name = unique(my_data$Name), user_id = 1:length(unique(my_data$Name))) # Соединяем таблицу данных с таблицей Id пользователей my_data &lt;- merge(x = my_data, y = user_id, by = &quot;Name&quot;, all.x = TRUE) # Удаляем столбец с именами my_data$Name &lt;- NULL # Добавляем к id пользователя суфикс my_data$user_id &lt;- paste0(&quot;user_&quot;, my_data$user_id) # Удаляем таблицу id пользователей rm(user_id) 5.4.3 Визуализация данных в Power BI с помощью визуального элемента скрипта R. Среди доступных визуальных элементов в Power BI есть элемент который называется “Визуальный элемент скрипта R”. Выбирите данный визуальный элемент и перенестине в область значений все поля из загруженной на прошлом шаге таблице, т.е. поля Id, user_id и Value. Необходимо помнить о том, что дубли строк обрабатываемой данным визуальным элементом таблицы будут удалены, избежать этого можно с помощью индексированного столбца, в нашем случае таким столбцом является поле Id, для того, что бы не удалять из таблицы нужные нам строки необходимо убрать агрегацию по столбцу Id. Код для построения график ящик с усами: boxplot(data = dataset, Value ~ user_id) Запись Value ~ user_id является формулой, с левой стороны от тильды записывается количественная переменная (Value), с правой стороны качественная переменная (user_id), если вы сделали всё верно на трёх предыдущих шагах, загрузили, преобразовали и визуализировали данные из файла name_values.csv в Power BI вы должны получить получить следующий результат, в случае если у вас что либо не получилось можно посмотреть готовый результат в файле m1_l3 - demo name_values. Результат который вы должны получить в ходе выполнения 3го урока 5.4.4 Использование пользовательских параметров Power BI в R скриптах. В Power BI при загрузки и преобразования данных с помщью R скриптов есть возможность передавать значение созданных вами параметров, для этого сначала необходимо создать параметры, значения которых вы в дальнейшем будете использовать в R скриптах. Задача: Создать два параметра, с помощью первого параметра мы будем менять файл из которого загружаем данные, с помощью второго можно будет менять используемый ранее префикс “user_” на любой другой. Создать параметры можно перейдя в редактор запросов. Создание параметров в Power BI Создав два параметра file_name и prefix_name, Выбираем запрос my_data, внутри которого будем использовать созданные параметры и переходим в расширенный редактор запросов. Переход в расширенный редактор запросов В запросе my_data мы дважды используем сценарий R, первый раз для загрузки данных, второй раз для их преобразования, соответвенно первый созданный параметр file_name мы будем использовать в части скрипта которая отвечает за загрузку данных, а параметр prefix_name в части скрипта преобразующего данные. Поиск необходимой части скрипта загрузки и преобразования данных Для использования значений параметров внутри R скриптов достаточно с помощью функции Text.From языка M получить текстовое значение параметра и конкатенировать его в текст запроса с помощью символа &amp;. Пример конкатенации значения параметра в R скрипт 5.5 Среда разработки RStudio Среда разработки RStudio состоит из 4ёх диалоговы окон. Редактор скриптов, предназначени для разработки и отладки кода, работая в этом окне удобно запускать отдельные части кода, искать нужные части кода, в этом окне удобно работает дополнение кода. Консоль, в консоли выводятся все запускаемые вами команды и результат их выполнения включая сообщения об ошибках при их возникновении. Рабочее окружение, в данном диалоговом окне вы можете найти все объекты оторые были созданны вами в ходе R сессии, в зависимости от класса объекта вы так же можнтн либо перейти к его детальному просмотру, либо получить какую либо дополнительную информацию по любому из объектов. Справка и визуализация, в данном окне выводится вся запрашиваемая вами справочничная информаци, а так же визуализация данных внутри R. Важно: Вы можете в любой момент получить справку по любой функции языка R с помощью команды ?имя_функции. 5.6 Классы объектов в языке R В языке R существует достаточно много классов объектов, но как правило используется 3: Вектор, Дата фрейм и Список. 5.6.1 Векторы Вектор это объект содержащий набор элементов одного типа, вы не можете хранить в одном векторе элементы имеющие разный тип данных, например число и текст. 5.6.1.1 Создание вектора В R есть довольно много способов создания векторов, но наиболее простым и используемым является использование функции c. # создание тектового вектора names &lt;- c(&quot;Алексей&quot;, &quot;Денис&quot;, &quot;Николай&quot;, &quot;Виктор&quot;, &quot;Денис&quot;) country &lt;- c(&quot;RU&quot;, &quot;UA&quot;, &quot;KZ&quot;, &quot;BY&quot;, &quot;BG&quot;, &quot;BR&quot;, &quot;TR&quot;, &quot;US&quot;, &quot;CA&quot;) age &lt;- c(34, 25, 39, 30, 28) # создание числового вектора nums &lt;- 5:20 # создание вектора из простой последовательсти чисел nums &lt;- seq(from = 5, to = 20) nums_2 &lt;- seq(from = 5, to = 20, by = 2) # создание вектора из последовательности чисел с определённым шагом nums_3 &lt;- seq(from = 5, to = 20, length.out = 9) # создание последновательсти чисел определённой длинны # создание вектора с именоваными элементами name_vector &lt;- c(name = &quot;Алексей&quot;, age = 34, company = &quot;Netpeak&quot;) 5.6.1.2 Обращение к элементам вектора ПОлучить один или несколько конкретных элементов вектора можно несколькими способами, по индексу, явно указав какие элементы вам нужны с помозью TRUE / FALSE, задав логическое выражение для фильтрации элементов вектора либо по именам в случае если вектор имеет иненованые элементы. names[2] # значение по его индексу names[-4] # исключить значения по индексу names[c(2,4)] # нескоько значений по индексам names[c(TRUE, TRUE, FALSE, TRUE)] # с помощью логического TRUE / FALSE name_vector[&quot;company&quot;] # зачение по его имени age[ age &gt; 31 ] # через логическое выражение which(age &gt; 31) # получить индексы элементов по логическому выражению 5.6.1.3 Свойства вектора С помощью ряда функций вы можете получить свойства вектора, например такие как длинна, тип данных или имена элементов. class(nums_3) # получить тип данных class(age) length(names) # получить количество элементов names(name_vector) # получить имена элементов 5.6.1.4 Манипуляция с элементами вектора С элементами вектора можно проводить люые манипуляции, сортировать, делать случайные выборки элементов и объенять несколько векторов в один. sort(country) # сортировка элементов вектора по возрастанию sort(country, decreasing = TRUE) # сортировка элементов вектора по убыванию unique(names) # получить список уникальных элементов вектора sample(x = country, # выборка случайных элементов из вектора size = 8, replace = F) # replace управляет возможность повтора элементов c(age, nums) # объеденение двух векторов Функция sample позволяет получить набор случайных элементов из вектора, аргумент size отвечает за количество элементов которые вернёт функция, аргумент replace позволяет запретить отбирать один и тот же элемент вектора несколько раз. 5.6.1.5 Логические операция с элементами векторов Все операции сравнения над векторами зациклены, т.е. даже если вы будете сравнивать между собой элементы двух векторов разной длинны то в ходе сравнения элементов более длинного вектора начнут сравниваться с начальными элементами короткого вектора. vec1 &lt;- c(5, 8, 1, 9) vec2 &lt;- c(5, 2, 10) vec1 &gt; vec2 vec1 &gt; 3 &amp; vec1 &lt; 9 # пример логического и vec1 &lt; 8 | vec1 &gt; 8 # пример логического или Для более сложных операций сравнения в которы необходимо использовать логические операторы И и ИЛИ следует использовать одиночные знаки. &amp; - И | - ИЛИ 5.6.2 Таблицы (data.frame) Объекты касса data.frame являются привычными для вас двухмерными таблицами, по сути таблица это набор векторов одинаковой длинны, каждое поле таблицы может содержать данные только одного типа, так же как и вектора. 5.6.2.1 Создание таблицы Создавать таблицы можно с помощью функции data.frame, каждое поле таблицы является вектором и может содержать данные одного типа, все векторы из которых состоят поля таблицы должны быть одинаковой длинны. # Пример создание таблицы пользователей users &lt;- data.frame(Names = names, Age = age, Country_id = sample(1:length(country), size = length(names), replace = T), Id = 1:length(names)) # Создаём таблицу - справочник стран country_dicy &lt;- data.frame(id = 1:length(country), country_name = sort(country)) В приведённом примере мы создали две таблицы: users - таблица состоит из 4 полей (Names, Age, Country_id, Id). country_dicy - таблица состоит из двух полей (id, country_name). 5.6.2.2 Обращение к элементам таблицы Образаться к любым элементам таблицы, строкам или столбцам, можно либо по индексу либо по имени, для получения какого либо элемента необходимо написать название таблицы, открыть квадратные скобки и указать сначала строки и после запятой столбцы которые вам необходимо получить. users[3, ] # получить 3 строку users[2:4, ] # получить 2-4 строку по номеру users[, 2] # получить 2 столбец users[[&quot;Age&quot;]] # получить столбец по имени users$Age # получить столбец по имени users[, c(&quot;Names&quot;, &quot;Id&quot;)] # получить несколько столбцов по имени users[, c(2, 3)] # получить несколько столбцов по номерам users[ users$Age &gt; 30, ] # получить строки по логическому выражению users$Names[ users$Age &gt; 30 ] # получить значения одного поля, по лог выражению другого поля head(users, n = 3) # получить верхние 3 строки таблицы tail(users, n = 3) # получить нижние три строки таблицы 5.6.2.3 Просмотрт структуры и описательных статистик таблиц Просмотр структуры таблицы, т.е. информации о том какие поля есть в таблице, и данные какого типа в каком поле храняться можно с помощью функции str. str(users) # структура таблицы ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ Names : Factor w/ 4 levels &quot;Алексей&quot;,&quot;Виктор&quot;,..: 1 3 4 2 3 ## $ Age : num 34 25 39 30 28 ## $ Country_id: int 9 4 2 6 7 ## $ Id : int 1 2 3 4 5 Получить описательные стаистики количественнх переменных и информацию о качественных переменных можно с помощью команды summary. summary(users) # описательные таблицы ## Names Age Country_id Id ## Алексей:1 Min. :25.0 Min. :2.0 Min. :1 ## Виктор :1 1st Qu.:28.0 1st Qu.:4.0 1st Qu.:2 ## Денис :2 Median :30.0 Median :6.0 Median :3 ## Николай:1 Mean :31.2 Mean :5.6 Mean :3 ## 3rd Qu.:34.0 3rd Qu.:7.0 3rd Qu.:4 ## Max. :39.0 Max. :9.0 Max. :5 5.6.2.4 Сортировка таблц Сортировка таблиц осуществляется с помощью функции order. # Сортировка таблиц users[ order( users$Age, decreasing = T), ] 5.6.2.5 Создание поднаборов таблиц Для создания поднабора данных в R существует функция subset, в которой вы может задать условия фильтрации по различным полям таблицы объединив несклько условий логическими И или ИЛИ, при этом следует использовать одиночные логические операторы (&amp;, |). # Выбираем поднабор состоящий из пользователей от 30 лет и старше users_after_30 &lt;- subset(x = users, Age &gt; 30, select = c(Id, Names)) # Выбираем пользователейв имени которых присутвует буква &quot;к&quot; и количество букв в имени более 5 users_i &lt;- subset(x = users, grepl(x = users$Names, pattern = &quot;к&quot;) &amp; nchar(as.character(users$Names)) &gt; 5, select = c(Id, Names)) 5.6.2.6 Объединение таблиц Для объединения таблиц служат следующие 3 функции: + rbind - Соединение таблиц по строкам + cbind - Соединение таблиц по столцам + merge - Соединение таблиц по ключу users_two &lt;- rbind(users_after_30, users_i) # объединения таблиц по строкам users_three &lt;- cbind(users_after_30 ,users_i) # объединение таблиц по столбцам # Объединение таблиц по ключу # Соединяем таблицу пользователей со справочником по id страны user_resul &lt;- merge(x = users, # левая таблица y = country_dicy, # правая таблица by.x = &quot;Country_id&quot;, # имя поля ключа в левой таблице by.y = &quot;id&quot;, # имя поля ключа в правой таблице all.x = TRUE) # тип соединения, в данном случае левое соединение Функция merge предназначена для соединения таблиц по ключам и принимает следующие аргументы: + x - левая таблица + y - правая таблица + by.x - ключи, название ключевых полей в левой таблице, если ключевых полей несколько их необзодимо передать в виде тектового вектора объединив их названия с помощью функции c. + by.y - ключи, название ключевых полей в правой таблице, если ключевых полей несколько их необзодимо передать в виде тектового вектора объединив их названия с помощью функции c. + all.x или all.y - аргументы которые управляют направлением соединения, allx = TRUE означает оставить все строки левой таблицы, т.е. левое соединение. 5.6.3 Списки (list) Объекты класса list могут являтся контейнерами для храннения других объектов, в том числе и других списков, как правило объекты класса list испоьзуются для хранения данныхимеющих сложную вложенную структуру, к примеру в виде списков удобно хранить данные прочитанные из JSON формата. 5.6.3.1 Создание списков my_list &lt;- list(user = list(id = 1, name = &quot;Alex&quot;, data = users[ users$Id == 1, ] )) my_list_2 &lt;- list(users, age, names, name_vector) 5.6.3.2 Обращение к элементам списка my_list$user$data$Names my_list_2[[4]] my_list_2[[4]][[2]] my_list_2[[4]][[&quot;company&quot;]] 5.6.4 Проверить класс объекта class(users) class(age) class(my_list) 5.7 Работа со строками на языке R 5.7.1 Базовые возможности для работы со строками в R В базовом R существует достаточно большой набор функций для работы со строками, ниже приведён пример манипуляции с текстовыми данными. # Конкатенация paste(&quot;Объелинить&quot;, &quot;несколько&quot;, &quot;строк&quot;) ## [1] &quot;Объелинить несколько строк&quot; paste0(&quot;Объелинить&quot;, &quot;несколько&quot;, &quot;строк&quot;) ## [1] &quot;Объелинитьнесколькострок&quot; paste(c(&quot;первый&quot;, &quot;текстовый&quot;, &quot;вектор&quot;), c(&quot;второй&quot;, &quot;вектор&quot;), collapse = &quot;-&quot;, sep = &quot;+&quot;) ## [1] &quot;первый+второй-текстовый+вектор-вектор+второй&quot; С помощью функций paste и paste0 можно объединять строкии склеивать текстовые векторы в кдиную строку, аргумент sep задаёт разделитель который будет добавлен между склеиваемыми частями, а аргумент collapse задаёт разделитель через который будут объедены результаты склеивания разных частей. Для извлечения части строки в R используется функция substr. text &lt;- c(&quot;Склеить&quot;, &quot;несколько&quot;, &quot;строк&quot;, &quot;в&quot;, &quot;одну&quot;) substr(text, start = 3, stop = 5) ## [1] &quot;леи&quot; &quot;ско&quot; &quot;рок&quot; &quot;&quot; &quot;ну&quot; Разбить строку через разделитель можно с помощью функции strsplit. my_string &lt;- &quot;Первая часть, вторая часть, третья часть&quot; strsplit(my_string, &quot;, &quot;) ## [[1]] ## [1] &quot;Первая часть&quot; &quot;вторая часть&quot; &quot;третья часть&quot; Примеры преобразования регистра строки. my_string &lt;- c(&quot;Разные РЕГИСТРЫ&quot;, &quot;ПрИМеР РеГисТРА&quot;) tolower(my_string) # перевод в верхний регистр toupper(my_string) # перевод в нижний регистр casefold(my_string, upper = TRUE) # перевод в верхний регистр casefold(my_string, upper = FALSE) # перевод в нижний регистр Работа с регулярными выражениями в R. # работа с регулярными выражениями grepl(x = text_with_spaces, pattern = &quot;^ &quot;, ignore.case = T) # проверить соответвует ли срока регулярному выражению gsub(pattern = &quot;^ | {2, }| $&quot;, replacement = &quot;&quot;, x = text_with_spaces) # замена части строки по регулярному выражению # получить подстроку соответвующую регулярному выражению m &lt;- regexpr(&quot;(.*о.*)&quot;, text) regmatches(x = text,m = m) 5.7.2 Работа со строками с помощью пакета stringr Базовые функции для работы со строками в R начительно различаются в стиле наименования как самих функций так и их аргументов, в связи с чеь замечательный пакет sringr, названия всех функций пакета начинаются с префикса str_, аргументы всех функций схожы. # преобразование строки str_c(text, c(&quot;раз&quot;, &quot;два&quot;, &quot;три&quot;), collapse = &quot;-&quot;, sep = &quot;+&quot;) # конкатенация строк str_replace_all(string = &quot;УбИрём одно слово&quot;, pattern = &quot;УбИрём&quot;, replacement = &quot;Уберём&quot;) # замена части строки str_to_lower(&quot;Перевод В Нижний Регистр&quot;) # перевод в нижний регистр str_to_upper(&quot;перевод в верхний регистр&quot;) # перевод в верхний регистр str_to_title(&quot;заглавная первая буква&quot;) # перевод в регистр заголовков str_remove_all(&quot;Уберём все пробелы&quot;, &quot; &quot;) # удаление символов из строки str_squish(&quot; Уберём лишние пробелы &quot;) # Удаление лишних пробелов str_split(&quot;Разобъём - строку - по - разделителю&quot;, &quot; - &quot;) # разбивка строки по разделителю str_pad(&quot;дополняем строку&quot;,side = &quot;both&quot;, width = 50, pad = &quot;$&quot;) # дополнение строки опредённым символов до нужного размера # извлечение части строки str_extract(pattern = &quot;(.*о.*)&quot;, string = text) # извлечение части строки по паттерну str_sub(&quot;Часть строки&quot;, start = 3, end = 7) # извлечние части строки по номеру символа word(&quot;Извлекаем слова по их номерам из предложения&quot;, 4, end = 7) # извлечение слова из предложения word(&quot;Извлекаем_слова_по_их_номерам_из_предложения&quot;, 4, end = 7, &quot;_&quot;) # извлечение слова из предложения разделённого _ # подсчёт символов str_length(&quot;Какая то большая строка&quot;) # посчитать количество символов str_count(string = &quot;посчитаем сколько раз встречается буква о&quot;, pattern = &quot;о&quot;) # считает количество входежний символа в строку # проверка строки str_detect(string = &quot; пробел&quot;, pattern = &quot;^ &quot;) # проверяет соответсвие строки регулярному выражению Так же пакет stringr дополнительно даёт возможность использовать объекты рабочего окружения и результаты работы функций в строках, т.е. конкатенировать созанные вами переменные или результат выполнения какой либо функции в строку, для этого в пакете есть две функции: str_glue и str_interp. str_glue - даёт возможность интерполировать внутрь строки значения из созданных в рабочем окружении объектов, имена объектов помещаются при этом в фигурные скобки. str_interp - используется для встраивания внутрь строки выражения, которое возвращается в результате рабоы каких либо функций языка R, для встраивания результата необходимо поставить знак долара и далее фигурных скобках написать выражение, результат которого вы хотите конкатенировать в строку. Примеры использования приведённых выше функций: # создаём переменные которые будем использовать в строках name &lt;- c(&quot;Alexey&quot;, &quot;Sergey&quot;) surname &lt;- c(&quot;Seleznev&quot;, &quot;Petrov&quot;) age &lt;- c(34, 38) city &lt;- c(&quot;Odessa&quot;, &quot;Moscow&quot;) # подстановка значений в строку из переменных stringr::str_glue(&quot;Hi, my name is {name} {surname}. I am {age} years old and i live in {city}.&quot;) ## Hi, my name is Alexey Seleznev. I am 34 years old and i live in Odessa. ## Hi, my name is Sergey Petrov. I am 38 years old and i live in Moscow. # подстановка результатов работы функций paste и mean в строку stringr::str_interp(&quot;Average age by ${paste(name, collapse = &#39; and &#39;)} is a ${mean(age)}&quot;) ## [1] &quot;Average age by Alexey and Sergey is a 36&quot; 5.8 Загрузка данных из csv, excel и json файлов в R 5.8.1 Загрузка данных из csv файлов Наиболее удобным и гибким способом загрузки данных в R из csv файлов является функция read.table, первый аргументом которой является путь к файлу, аргумент sep отвечает за то, какие разделители полей используются в csv файле, и аргумент header принимает логическое значение TRUE или FALSE, и с его помощью вы можете указать что первая строка в вашем csv файле содержит заголовки полей. Пример кода для загрузки данных из csv файла, все файлы находятся в папаке матриалы курса - модуль 1 - урок 7. # Переходим в работую директорию setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) sales &lt;- read.table(&quot;sales.csv&quot;, sep = &quot;;&quot;, header = T) country &lt;- read.table(&quot;country.csv&quot;, sep = &quot;;&quot;, header = T) clients &lt;- read.table(&quot;clients.csv&quot;, sep = &quot;;&quot;, header = T) product &lt;- read.table(&quot;product.csv&quot;, sep = &quot;;&quot;, header = T) 5.8.2 Загрузка данных из Excel файлов Для работы с Excel файлами необходимо установить и подключить пакет readxl, для этого необходимо выполнить функции install.packages и library, далее с помощью функции read_excel можно прочитать данные из любого листа Excel книги. ## загрузка данных из Excel файлов install.packages(&quot;readxl&quot;) library(readxl) bad_format_data &lt;- read_excel( &quot;tidyr_example.xlsx&quot; , sheet = &quot;tidyr_example&quot;, col_names = T) 5.8.3 Загрузка данных из JSON файлов Для работы с JSON форматом необходимо загрузить и подключить пакет jsonlite. install.packages(&quot;jsonlite&quot;) library(jsonlite) data_from_json &lt;- read_json(&quot;dictionary.json&quot;) 5.9 Агрегирующие функции и арифметические операции в R Пример работы с наиболее часто используемыми агрегирующими функциями. # Агрегирующие функции sum(sales$quantity) # суммирование mean(sales$quantity) # среднее арифметическое median(sales$quantity) # медиана quantile(sales$quantity, probs = 0.25) # квантиль length(sales$quantity) # количество length(unique(sales$manager)) # количество уникальных Арифметические операции: # Арифметические операции 5 + 2 # сложение 5 - 2 # вычитание 5 * 2 # умножение 5 / 2 # деление 5 ** 2 # степень 5 %/% 2 # целочисленное деление 5 %% 2 # остаток от целочисленного деления 5.10 Манипуляция с данными, (группировка и агреция). 5.10.1 Пакет dplyr Пакет dplyr является наиболее популярным пакетом для работы с данными в R, все функции пакета представляют из себя глаголы, синтаксис пакета очень напонимает синтаксис SQL запросов. Основные команды для работы с данными в пакете dplyr select - выбор полей из data.frame filter - фильтрация данных arrange - сортировка данных group_by - группировка данных summarise - агрегация данных Соединение таблиц осуществляется с помощью функций семейства join: inner_join - возвращает строки общие для обеих таблиц соединения left_join - левое соединение, возвращает все строки из левой таблицы, и соответвующие по ключи строки из правой таблицы right_join - правое соединение, возвращает все строки из правой таблицы, и соответвующие по ключи строки из левой таблицы full_join- декартово произведение, возвращает все вараинты соединения каждой строки из левой таблицы с каждой сторокой из право таблицы Операция JOIN Фильтрующие соединения: semi_join - возвращает все строки из левой таблицы, для которых по ключу найдены соответвия в правой таблице anti_join - возвращает все строки из левой таблицы, для которых по ключу небыли найдены соответвия в правой таблице Конвеерный синтаксис В пакет dplyr из пакета magrittr был взаимствован конвеерный оператор %&gt;%, с помощью него можно избегать создание промежуточных объектов, данный оператор передаёт в качестве первого аргумента функции результат выпонения функции на прошлом шаге, если вам необходимо передать результат выполнения прошлого шага не в первый, а какой либо другой аргумент функции на следующем шаге то вы можете воспользоваться точкой, которая и будет хранить результат выполнения прошлого шага. Пример конвеерной записи преобразования данных library(dplyr) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) sales &lt;- read.table(&quot;sales.csv&quot;, sep = &quot;;&quot;, header = T) # конверный стиль записи sales %&gt;% group_by(manager) %&gt;% # группируем таблицу по полю manager summarise(count = n(), # считаем количество строк по каждому менеджеру total_quantity = sum(quantity), # считаем количество проданных едениц товара average_quantity = mean(quantity), # считаем среднее количество едениц товара в транзации products = length(unique(product_id))) %&gt;% # считаем какое к-во наименований товара продал менеджер arrange(-total_quantity) %&gt;% # сортирум таблицу по полю total_quantity по убыванию head(3) # оставляем 3 верхние строки Приведённый выше код делает следующе, передаёт в первый аргумент функции group_by, с помощью конвеерного оператора %&gt;% объкт sales и тем самым группирует дата фрейс sales по полю manager. Результат группировки, опять же с помощью конвеерного оператора %&gt;% передаётся в качестве первого аргумента функции summarise, далее к сгруппированным данным применяется ряд агрегаций, функции n() считает количество строк попавших в каждую группу, функция sum суммирует данные в каждой группе по полю quantity, функция mean считает среднее значение по полю quantity, а конструкция length(unique(product_id)) считает количество уникальных product_id в каждой группе. После агрегации мы через конвеерный оператор %&gt;% передаём полученный на прошлом шаге результат в качестве первого аргумента функции arrange, и производим сортиртировку по убыванию поля total_quantity, передаём отсортированный результат далее в функцию head через %&gt;% и оставляем первые три строки. В итоге мы получим следующий результат: manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 Пример работы с фильрующими соединениями # фильтрующие соединения anti_join(product, sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) # товары по которым не было транзакций semi_join(product, sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) # товары по которым были транзакции 5.10.2 Пакет data.table Пакет data.table предназначен для работы с большими массивами данных, по своему синтаксису он похож на работу с обычными data.frame, но в квадратных скобках мы указываем не только строки и столбцы которые необходимо выбрать, но и можем задавать группировку и агрегацию данных. Загрузка данных с помощью data.table Для загрузки данных из csv файлов в data.table есть функция fread, она принимает теже аргументы, что и стандартная функция read.table но работает в разы быстрее, и создаёт объекты класса data.table. Синтаксис пакета data.table Синтаксис data.table Обращение к полям таблиц, агрегация и группировка данных в data.table осуществляется внутри квадратных скобок, сначала мы указываем какие строки хотим выбрать, потом указываем агрегирующие операции и поля которые хотим в результате получить, и в третем блоке с помощью аргумента by или bykey мы указываем поля по которым хотим сгруппировать результат. Вместо конвеерных операций расмотренных в пакете dplyr, в data.table существуют цепочки, записываются они следующим образом: data_table_name[1ое звено][2ое звено][3ее звено][4ое звено][...] Таким образом каждое следующее звено работает с результатом полученным из прошлого звена. Пример работы с пакетом data.table С помощью синтаксиса data.table мы можем получить тот же резуьтат, что и при работе с dplyr: library(&quot;data.table&quot;) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) # загрузка данных sales_dt &lt;- fread(&quot;sales.csv&quot;) sales_dt[, .(count = .N, # считаем количество строк по каждому менеджеру total_quantity = sum(quantity), # считаем количество проданных едениц товара average_quantity = mean(quantity), # считаем среднее количество едениц товара в транзации products = length(unique(product_id))), # считаем какое к-во наименований товара продал менеджер by = manager][order(total_quantity, decreasing = TRUE)][1:3,] Приведённый выше код вернёт результат аналогичный тому, который был получен ранее при работе с пакетом dplyr. manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 5.10.3 Пакет sqldf sqldf является менее популярным пакетом по сравнению с dplyr и data.table, основным его назначением является возможность манипулировать с данными с помощью SQL синтаксиса. Пакет поддерживает 4 SQL диалекта: SQLite (по умолчанию), MySQL, PostgreSQL, H2. Для того, что бы установить нужный диалект необходимо поменять опцию sqldf.driver. options(sqldf.driver = &quot;SQLite&quot;) Для того, что бы получить с помощью пакета sqldf результат аналогичный тому, что мы ранее получили с помощью пакетов dplyr и data.table необходимо выполнить следующий код. library(sqldf) # повторяем агрегацию применяемую в примере с dplyr и data.table sqldf_exampl &lt;- sqldf(&quot;SELECT manager, COUNT(*) as count, SUM(quantity) as total_quantity, AVG(quantity) as average_quantity, COUNT(DISTINCT product_id) as products FROM sales GROUP by manager ORDER BY total_quantity DESC LIMIT 3&quot;) В результате его выполнения, мы получим уже знакомый результат агрегации данных. manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 5.10.4 Пакет tidyr Данный пакет предназначен для придания данным так называемого аккуратного вида, так такую концепцию данных называют Tidy data, заключается она в том, что наиболее удобно работать с данными приведёнными к такому виду, когда каждая строка таблицы соответствует одному наблюдения, а каждый столбец хранит информацию об одном свойстве наблдений. Задача: в материалах курса есть файл tidyr_example.xlsx, найти его можно в папке материале курса / модуль 1 / урок 7. Сам файл представляет из себя таблицу следующего вида: файл tidyr_example.xlsx Довольно часто коллеги предоставляют вам данные именно в таком виде,но работать с такими данными неудобно, т.к. существуют следующие ошибки. Поле country было сгруппировано в Excel, и при загрузке данных в R большая часть ячеек в этом поле не будут заполнены. Поле client_code содержит код клиента, который в свою очередь хранит информацию сразу о трёх его свойствах, о сегмента клиента, его номер, и класс клиента, в данном случае все три свойства хранятся в одном поле, что не соответвует концепции Tidy data. 4 столбца хранят информацию о количестве продаж в кокретном месяце, но месяц является отдельным свойством наблюдения, и название месяцаа должно храниться в отдельном столбце, и количество продаж в конкретном месяце так же необходимо хранить как отдельное свойство продажи. Пакет tidyr предоставляет набор функций с помощью которых можно исправить все перечисленные выше проблемы и привести данные к аккуратному виду. Функции в tidyr fill - заполнение пропущенных значений в поле, в нашем случае заполнение поля country separate - разделяет одно поле на несколько, в нашей задаче нам необходимо разбить поле client_code на 3 поля client_segment, client_id и client_class. unite - совершает операцию объеденения нескольких полей в одно, дейтсвие обратное функции separate. gather - функция преобразующая данные из широкого формата в длинный,в нашем случае мы будем с помощью неё преобразовывать поля June, July, Aug, Sept в два поля month, в котром будет хранится название месяца и sales_count, в котором будет хранится информация о количестве продаж. spread - функция преобразующая данные из длинного формата в широкий, операция обратнаяя той, которую осуществляет функция gather. Для решения приведённой задачи с помощью конвеерного стиля необходимо выполнить следующий код: library(tidyr) library(readxl) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) bad_format_data &lt;- read_excel( &quot;tidyr_example.xlsx&quot; , sheet = &quot;tidyr_example&quot;, col_names = T) good_data &lt;- bad_format_data %&gt;% fill(country) %&gt;% separate(col = client_code, into = c(&quot;client_segment&quot;, &quot;client_id&quot;, &quot;client_class&quot;), sep = &quot;_&quot;) %&gt;% gather(key = &quot;month&quot;, value = &quot;sales_count&quot;, June:Sept) В рузультате чего мы приведём наши данные к аккуратному виду, (верхние 20 строк результирующей табицы): country client_segment client_id client_class month sales_count UA c2с 1 a June 74 UA b2b 2 a June 45 UA c2с 3 c June 37 UA c2с 4 b June 87 UA c2с 5 a June 55 RU b2b 2 b June 66 RU c2с 4 a June 70 RU b2b 5 a June 62 KZ b2b 8 c June 57 KZ c2с 6 b June 51 KZ c2с 9 a June 43 KZ b2b 10 b June 62 KZ b2b 2 b June 44 KZ c2с 3 c June 60 KZ c2с 11 b June 48 KZ b2b 12 c June 62 UA c2с 1 a July 87 UA b2b 2 a July 58 UA c2с 3 c July 31 UA c2с 4 b July 65 5.11 Работа с датами и временем в R, пакет lubridate. 5.11.1 Базовые возможности по работе с датой и временем в R В R дата и время являются отдельным типом данных, базовые функции для работы с датами предоставляют следующие возможности. Sys.Date() # текущая дата Sys.Date() - 7 # дата которая была 7 дней назад Sys.time() # текущая дата и время Sys.timezone() # часовой пояс first_day_in_2018 &lt;- as.Date(&quot;2018-01-01&quot;) # преобразование текста в дату class(first_day_in_2018) # проверка того, является ли переменная датой # последовательность дат date_vector &lt;- seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), by = &quot;month&quot;) seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), by = &quot;week&quot;) seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), length.out = 10) 5.11.2 Пакет lubridate Довольно общирные возможности по работе с датой и временем предоставляет пакет пакет lubridate. library(lubridate) today() # текущая дата date() # текущая да now() # текущая дата и время start_time &lt;- now() 5.11.2.1 Преобразование строки в дату с помощью функций lubridate Для преобразования строки в дату в lubridate существует набор функций, все эти функции состоят из первых букв состовляющих даты, y - год, m - месяц и d - день. # преобразовать строку в дату ymd(&quot;20180715&quot;) # преобразум стоку формата ГГГГММДД в дату ymd(&quot;2018-07-15&quot;) # преобразум стоку формата ГГГГ-ММ-ДД в дату mdy(&quot;07152018&quot;) # преобразум стоку формата ММДДГГГГ в дату dmy(&quot;15.07.2018&quot;) # преобразум стоку формата ДД.ММ.ГГГГ в дату ymd_hms(&quot;2018-07-15 12:30:00 Europe/Helsinki&quot;) # преобразуем строку ГГГГ-ММ-ДД ЧЧ:ММ:СС в дату и время 5.11.2.2 Работа с часовыми поясами в lubridate. # часовые пояса my_time &lt;- now() OlsonNames(tzdir = NULL) # список всех часовых поясов with_tz(my_time, tzone = &quot;UTC&quot;) # преоразуем в временную метку в часовой пояс UTC with_tz(my_time, &quot;America/Chicago&quot;) # преоразуем в временную метку в часовой пояс America/Chicago 5.11.2.3 Извлечение отдельных компонентов даты с помощью функций пакета lubridate # получить день, месяц и год из даты today_date &lt;- today() day(today_date) # получить день из даты month(today_date) # получить месяц из даты year(today_date) # получить месяц из даты quarter(today_date) # получить номер квартала из даты qday(today_date) # получить номер дня в квартале yday(today_date) # получить номер дня в году # получить днь недели wday(today_date, label = TRUE, abbr = TRUE, week_start = 1) 5.11.2.4 Округление, и прочие арифметические операции с датами с помощью lubridate # округление дат round_date(today_date, unit = &quot;month&quot;) # округлить до ближайшего месяца round_date(today_date, unit = &quot;quarter&quot;) # округлить до ближайшего квартала floor_date(today_date, unit = &quot;month&quot;) # округлить вниз до ближайшего месяца ceiling_date(today_date, unit = &quot;month&quot;) # округлить вверх до ближайшего месяца ceiling_date(today_date, unit = &quot;quarter&quot;) # арифметичские операции с датами today() - months(6) # 6 месяцев назад от текущей даты # получить первый и последний прошлого квартала today() - qday(today()) # получаем конец прошлого квартала floor_date(today() - qday(today()), unit = &quot;quarter&quot;) # получаем начало прошлого квартала # получить первый и последний прошлого месяца floor_date(today() - day(today()), unit = &quot;month&quot;) today() - day(today()) 5.11.2.5 Операции над данными со временм в lubridate # Работа со временем в R # вычисление длительности end_time &lt;- now() difftime(end_time, start_time, units = &quot;secs&quot;) # в секундах difftime(end_time, start_time, units = &quot;mins&quot;) # в минутах end_time + hours(30) # прибавить 3 часа end_time + minutes(15) # прибавить 15 минут hour(end_time) # получить часы из времени minute(end_time) # получить минуты из времени second(end_time) # получить секунды из времени 5.12 Условные конструкции if, ifelse, switch в R Для работы с уловными конструкциями в R существует оператор if, функция ifelse и функция switch. Наиболее простой способ использования условий в R предоставляет функция ifelse, по синтаксису она идентична функции ЕСЛИ в Excel. vec_1 &lt;- runif(n = 30, min = 5, max = 50) # векторизированный оператор ifelse ifelse(vec_1 &gt; 25, &quot;Больше 25&quot;, &quot;Меньша 25&quot;) В случае если вам необходимо проверить более чем одно условие необхимо использовать конструкцию if - else. Синтаксис оператора if x &lt;- 10 # условная конструкция if if (x &lt; 25) { print(&quot;x меньше 25&quot;) } else if (x &lt;= 40) { print(&quot;x больше 25 но меньше 40&quot;) } else { print(&quot;x больше 40&quot;) } Таким образом можно добавлять люое количество условий с помощью оператров else if, далее добавляется обычный оператор else Функция switch напоминает привычный для SQL оператор CASE, она принимает все варианты возможных взодящих параметров, и для кадого входящего параметра определяет значение которое необходимо вернуть. employ_name &lt;- &quot;Alexey&quot; # переключатель, аналог case switch (employ_name, Alexey = 3, Sergey = 1.5, Denis = 2, Nikolay = 4, 0) 5.13 Циклы for и while 5.13.1 Цикл for Цикл for представляет из классический цикл со счётчиком. Простейший пример пример цикла for: # Цикл for employ_name &lt;- c(&quot;Alexey&quot;, &quot;Sergey&quot;, &quot;Nikolay&quot;) for (name in employ_name) { print(paste(&quot;Hello&quot;, name)) } for (i in 1:length(employ_name)) { print(paste(&quot;Hello&quot;, employ_name[i])) } В данном случае цикл будет состоять из трёх итераций, на каждой итерации в переменную-счётчик name будет подставлен один элемент вектора employ_name. Задача: В материалах курса, в папке модуль 1 - урок 9, есть 7 csv файлов одинаковой структуры, довольно часто встречается задача когда необходимо объеденить данные из файлов одинаковой структуры в один. Нам необходимо реализовать процесс склейки файлов в одну таблицу в R. # загрузка данных из множества файлов одинаковой структуры setwd( &quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 9&quot;) # переходим в рабочую директорию library(dplyr) # подключаем пакет dplyr files &lt;- dir() # получаем список файлов из рабочей директории load_files &lt;- files[ grepl(&quot;^data_from&quot;, files) ] # оставляем список файлов который начинается на load_data load_data &lt;- list() # создаём объек класса list в который будет загружать файлы for (f in load_files) { load_data &lt;- c(load_data, # по очереди загружаем каждый файл и присоединяем к объекту load_data list(read.table(f, sep = &quot;;&quot;, header = T))) } data &lt;- bind_rows(load_data) # преобразуем загруженные файлы в data.frame C помощью команы setwd мы делаем нужную папку нашим рабочим каталогом. Далее функция dir возвращает вектор, состоящий из имён всех файлов которые находятс яв рабочем каталоге. Т.к. помимо нужных нам файлов в каталоге присутвуют и другие, то с помощью grepl и регулярного выражения ^data_from мы оставляет только те файлы, имена которых начинаются на data_from, и созраняем их в вектор load_files. Создаём пустой список load_data, в который по очереди будем добавлять загруженные данные. С помощью цикла for мы перебираем по очереди все имена файлов из вектора load_files, и подставляем их в функцию read.table, в данном случае переменной-счётчиком у нас является объект f, заданный в круглых скобках после объявления цикла for. После загрузки всех файлов мы объединяем их в одну таблицу с помощью функции bind_rows из пакета dplyr. 5.13.2 Цикл while Цикл while используется в том случае если до запуска цикла мы не знаем точное количество итераций, он будет выполняться до тех пор пока будет возвращать истину заданное после его объявление логическое выражение. # Цикл whie x &lt;- 0 while ( x &lt; 7 ) { print(paste(&quot;x равен&quot;, x)) x &lt;- x + 1 } В данном пример цикл будет выполняться до тех пор пока переменная x будет меньше 7, при этом на кажой итерации цикла мы увеличиваем значение переменной x на единицу с помощью конструкции x &lt;- x + 1. Ещё рлин пример работы с циклом while. input &lt;- &quot;&quot; while (input != &quot;stop&quot;) { input &lt;- readline(&quot;Введите текст: &quot;) print(paste0(&quot;Ваш текст: &quot;, input)) } Этот цикл проси ввести значение с клавиатуры с помощью функции readline, и итерации будут продолжаться до тех пор, пока вы не введёте слово stop. Возможно вы захоьите добавить дополнительную проверку, и выйти из цикла while даже если основное условие по прежнему возвращает истину, допустим вы хотите ограничить количество итераций, для этого в R существует оператор break. input &lt;- &quot;&quot; n &lt;- 0 while (input != &quot;stop&quot;) { input &lt;- readline(&quot;Введите текст: &quot;) print(paste0(&quot;Ваш текст: &quot;, input)) n &lt;- n + 1 if (n &gt; 3) { print(&quot;Вы вводили текст более трёх раз, цикл окончен&quot;) break } } Так же и как в прошлом примере R будет просить ввести текст, цикл будет итерироваться до тез пор пока вы не введёте слово stop, но мы парралельно ввеи счётчик n, который увеличиваем на 1 с каждой новой итерацией n &lt;- n + 1, далее в теле цикла с помощью условной конструкции if проверяется условие n &gt; 3, если n более трёх мы выводим сообщение Вы вводили текст более трёх раз, цикл окончен, и выходим из цикла с помощью оператора break. 5.14 Разработка собственных функций в языке R Создание собственных функций осузествляется с помощью оператора function. Функция, так же как и всё, что мы создаём в рабочем окружении, является объектом, поэтому создаётся функция так же, мы указываем имя фунции и пишем знак присвоения &lt;-. Далее пишем оператор function, в скобкаъ перечисляем все аргументы, осткрываем фигурную скобку после чего пишем тело функции, результат выполнения функции мы возвращаем передав его внутри тела функции в return. # простая функция my_fun_sum &lt;- function(x, y, z) { result &lt;- (x + y) * z return(result) } my_fun_sum(10, 15, 2) # функция с переключателем agr &lt;- function (x, type) { switch(type, mean = mean(x), median = median(x), sum = sum(x), quantiles = quantile(x, probs = c(0.25, 0.5, 0.75))) } agr(c(5, 17, 32, 15), type = &quot;mean&quot;) agr(c(5, 17, 32, 15), type = &quot;quantiles&quot;) # функция для загрузки файлов file_loader &lt;- function(prefix, ...) { # получаем список файлов из рабочей директории files &lt;- dir() # оставляем список файлов который начинается на load_data load_files &lt;- files[ grepl(prefix, files) ] # создаём объек класса list в который будет загружать файлы load_data &lt;- list() # циклом обрабатываем каждый файл for (f in load_files) { load_data &lt;- c(load_data, # по очереди загружаем каждый файл и присоединяем к объекту load_data list(read.table(f, ...))) } data &lt;- bind_rows(load_data) # преобразуем загруженные файлы в data.frame # возвращаем полученный результат return(data) } my_files &lt;- file_loader(prefix = &quot;^data_from&quot;, sep = &quot;;&quot;, header = TRUE) В примере выше показаны варианты разработки как самой элементарной пользовательской функции которая просто производит арифметические операции над треммя введёными аргументами, так и более сложная которая выполняет все действия для загрузки и объединения данных из множества csv файлов, которые мы рассматривали ранее изучая цикл for. 5.15 Обработка ошибок в R, функция try Достаточной важной частью разработки какого либо скрипта является обработка ошибок, давайте рассмотрим пример с ошибкой. возникающей в работе цикла. test_error_list &lt;- list(5, 12, 8, &quot;u&quot;, 3, 7, 9) for ( i in 1:length(test_error_list)) { print(paste0(&quot;i is &quot;, test_error_list[[i]])) print(test_error_list[[i]] * 12) } ## [1] &quot;i is 5&quot; ## [1] 60 ## [1] &quot;i is 12&quot; ## [1] 144 ## [1] &quot;i is 8&quot; ## [1] 96 ## [1] &quot;i is u&quot; ## Error in test_error_list[[i]] * 12: нечисловой аргумент для бинарного оператора Цикл, по очереди должен умножить каждой элемент списка test_error_list на 12, в начале тела цикла с помощью команды print мы выводим сообщение о том, какое значение имеет текущий, обратаваесый элемент. Цикл успешно умножил на 12 первые три элемента списка test_error_list, но 4ый элемент является текстовым, а R не умеет производить арифметические операции над текстом, возвращает ошибку, и цикл аварийно прекращает работу до того как он обработал все аргументы. Но мы с помощью функции try можем предусмотреть вариант возникновения ошибки при умножении следующим образом. test_error_list &lt;- list(5, 12, 8, &quot;u&quot;, 3, 7, 9) # обработка ошибок for ( i in 1:length(test_error_list)) { print(paste0(&quot;i is &quot;, test_error_list[[i]])) check_result &lt;- try (test_error_list[[i]] * 12, silent = TRUE) if (class(check_result) == &quot;try-error&quot;) { print(paste(&quot;error: &quot;, as.character(attr(check_result, &quot;condition&quot;)))) next } else { print(check_result) } } ## [1] &quot;i is 5&quot; ## [1] 60 ## [1] &quot;i is 12&quot; ## [1] 144 ## [1] &quot;i is 8&quot; ## [1] 96 ## [1] &quot;i is u&quot; ## [1] &quot;error: Error in test_error_list[[i]] * 12: нечисловой аргумент для бинарного оператора\\n&quot; ## [1] &quot;i is 3&quot; ## [1] 36 ## [1] &quot;i is 7&quot; ## [1] 84 ## [1] &quot;i is 9&quot; ## [1] 108 В скрипте выше, мы завернули вычисление test_error_list[[i]] * 12 в функцию try, которая не смотря на то, что в ходе цикла возникла ошибка продолжает его работу, но объект который она вернёт будет иметь класс try-error, для проверки корретно ли отработало вычисление мы добавили условную конструкцию if (class(check_result) == &quot;try-error&quot;), и в случае если умножение вернуло ошибку мы выводим сообщение, и переходим на следующую итерацию цикла с помощью команды next. 5.16 Рекомендации по оформлению кода для упрощения его читаемости Названия всех объектов должны быть понятными и осмысленными. Необходимо придерживаться единого стиля в именовании функций и их аргументов: snake_case, lowerCamelCase, UpperCamelCase, period.separated. Используйте в качестве знака присвоения -&gt; а не знак равенства, который в R принято использовать только в качестве знака присвоения для аргумнтов функций. Пробелы ставяться до и после математических символов, операторов присвоения в том числе операторов присвоения аргументов, логических операторов. Пробелы ставяться после запятых и управляющих конструкций if, for, while. Если функция имее большое количество аргументов для улучшение читаемости кода переносите каждый агрумент на новую строку, так же улучшит восприятие кода выравнив по строкам знаки присвоения значений аргументам добавив между именем аргумента и знаком = дополнительные пробелы, такой же приём можно использовать если в начале скрипта вы объявляете большое количество переменных. Во всех своих скриптах лучше придерживаться единой структуры кода, например я использую такой подход: 6.1. Подключение библиотек library 6.2. Переход в рабочую директорию setwd 6.3. Описание всех пользовательских функций используеых в скрипте function 6.4. Подключение к базам данных dbConnect 6.5. Аутентификация в API 6.6. Основная часть кода 6.7. Закрываем соедения с базами данных dbDisconnect. Если в одном скрипте используюстся функции из множества различных пакетов явно указывайте к какому паету принадлежик каждая функция package_name::function_name(). Комментируйте код, это улучшить навигцию по коду при работе в RStudio, и значительно упростить понимание кода в последствии. R не требует обязательного указания имён аргументов функций, но я рекомендую всегда явно описывать их имена если вы используете в функции более одно, явного и обязательного аргумента. "],
["-2-api-.html", "6 Модуль 2: Работа с API рекламных площадок. 6.1 Что такое API 6.2 Работа с API Google Ads 6.3 Работа с API Яндекс Директ 6.4 Работа с API Facebook 6.5 Работа с API Вконтакте (vk.com) 6.6 Работа с API MyTarget 6.7 Загрузка данных из Google Analytics 6.8 Загрузка данных из API Яндекс Метрики, Yandex Metrica 6.9 Работа с Google Search Console 6.10 Работа с Google Trends 6.11 Парсинг веб сайтов, Web scrapping 6.12 отправка HTTP запросов", " 6 Модуль 2: Работа с API рекламных площадок. 6.1 Что такое API Взаимодействие пользователя с различными программами осуществляется с помощью графического интерфейса программы, пользователь взаимодействует с элементами графического интерфейса, такими как кнопки, списки, меню и таким образом задаёт программе различные команды которая она должна выполнить. Подобное взаимодействие между двумя приложениями осуществляется с помощью API интерфейса, вместо элементов графического интерфейса в API используются различные методы, с помощью которых одно приложение задаёт другому какие либо команды. Взаимодейтсвие между двумя приложениями Взаимодействие происходит с помощью HTTP запросов, которое одно приложение (клиент) отправляет другому (сервер), далее сервер обрабатывает входящий запрос и отправляет обратно клиенту ответ. 6.1.1 Типы HTTP запросов HTTP запросы в свою очередь бывают разных типов, от типа запроса зависит действие которое каждый запрос выполняеи, наиболее часто встречающиеся это: PUT - Создание; GET - Чтение; POST - Изменение; DELETE - Удаление. В свою очередь все запросы состоят из нескольких компонентов: URL – URL адрес сервера; Headers – Заголовки запроса; Body – Тело запроса. Сервер, приняви обработав запрос от клиент, возвращает ответ, ответ от сервера имеет статус, в котором указано успешно ли был выполнен ваш запрос, все статусы деляться на 5 классов, класс статса определяется по первой цыфре его кода. 1xx – Информационные; 2xx – Запрос выполнен успешно; 3xx – Redirect; 4xx– Ошибка клиента; 5xx – Ошибка сервера. 6.2 Работа с API Google Ads 6.2.1 Как получить доступ к API Google Ads Актуальная информация о том как получить доступ к API Google Ads можно получить в официциальноц справке. Для доступа Вам необходимо: Создать центр клиентов, перейдите по этой ссылке и зарегистрируйте новый центр клиентов, обратите внимание, что центр клиентов можно создать толко в том Google аккаунте к которому ещё не привязан ниодин аккаунт Google Ads. Далее необходимо подать заявку на доступ к API, перейдите в Настройки (значок шестеренки в правом верхнем углу) &gt; Настройки аккаунта (раскрывающееся меню) &gt; Центр API AdWords (меню слева). Запонлите все поля и перейдите в форму заполненеия завки нажав на “Уровень доступа”. Далее ваша заявка будет рассмотрена и ободобрена. СОздаём приложение в Google Cloud, для этого переходим в консоль google cloud, создаём первый проект, и в нём идём в меню &gt; API и сервисы &gt; учётные данные. Google Cloud Далее жмём кнопку “создать учётные данные” и выбираем “Идентификатор клиента OAuth”. . 6.2.2 Как устроен API Google Ads Google Ads является наиболее популярной системой онлайн реклмы в миру, и имеет довольно мощный API интерфейс для работы со статистикой. API состоит из 48 отчётов (версия 201806): ACCOUNT PERFORMANCE REPORT AD CUSTOMIZERS FEED ITEM REPORT AD PERFORMANCE REPORT ADGROUP PERFORMANCE REPORT AGE RANGE PERFORMANCE REPORT AUDIENCE PERFORMANCE REPORT AUTOMATIC PLACEMENTS PERFORMANCE REPORT BID GOAL PERFORMANCE REPORT BUDGET PERFORMANCE REPORT CALL METRICS CALL DETAILS REPORT CAMPAIGN AD SCHEDULE TARGET REPORT CAMPAIGN CRITERIA REPORT CAMPAIGN GROUP PERFORMANCE REPORT CAMPAIGN LOCATION TARGET REPORT CAMPAIGN NEGATIVE KEYWORDS PERFORMANCE REPORT CAMPAIGN NEGATIVE LOCATIONS REPORT CAMPAIGN NEGATIVE PLACEMENTS PERFORMANCE REPORT CAMPAIGN PERFORMANCE REPORT CAMPAIGN SHARED SET REPORT CLICK PERFORMANCE REPORT CREATIVE CONVERSION REPORT CRITERIA PERFORMANCE REPORT DESTINATION URL REPORT DISPLAY KEYWORD PERFORMANCE REPORT DISPLAY TOPICS PERFORMANCE REPORT FINAL URL REPORT GENDER PERFORMANCE REPORT GEO PERFORMANCE REPORT KEYWORDLESS CATEGORY REPORT KEYWORDLESS QUERY REPORT KEYWORDS PERFORMANCE REPORT LABEL REPORT LANDING PAGE REPORT MARKETPLACE PERFORMANCE REPORT PAID ORGANIC QUERY REPORT PARENTAL STATUS PERFORMANCE REPORT PLACEHOLDER FEED ITEM REPORT PLACEHOLDER REPORT PLACEMENT PERFORMANCE REPORT PRODUCT PARTITION REPORT SEARCH QUERY PERFORMANCE REPORT SHARED SET CRITERIA REPORT SHARED SET REPORT SHOPPING PERFORMANCE REPORT TOP CONTENT PERFORMANCE REPORT URL PERFORMANCE REPORT USER AD DISTANCE REPORT VIDEO PERFORMANCE REPORT Посмотреть актуальный список отчётов можно в официальной документации, там же доступно описание каждого отчёта. Каждый отчёт отвечает за группировку данных и в свою очередь состоит из полей, каждое поле отчёта может иметь один из трёх типов. Google Ads API report Атрибут - поле содержит фиксированное значение в соответствии с заданными группировками, добавление такого поля в отчет не приводит к появлению новой группировки; Сегмент - при выводе в отчете поле используется для группировки данных; Метрика - поле содержит числовое значение, рассчитанное в соответствии с заданными фильтрами и группировками. Обращаячь к API вы запрашиваете какие либо поля из любого отчёта, и получается таким образом нужную вам статистику. 6.2.3 Пакет RAdwords Для работы с API Google Ads в R существует пакет RAdwords. Ранее, все пакеты которые мы устанавливали, мы скачивали и инсалировали из основного репозитория хранения данных в R CRAN, но пакеты в этом репозитории обновляются медленее чем dev версии пакетов ранящиеся у авторов на GitHub, для установки наиболее актуальных версий пакетов непосредственно из GitHub нам надо установить пакет *devtools** и далее устанавливать пакеты с помощью функции install_github, указав логин автора пакета и название репозитория в котором хранится пакет. Например для установки пакета **RAdwords* из репозитория автора можно использовать следующий код: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;jburkhardt/RAdwords&quot;) Где jburkhardt/RAdwords это логин автора RAdwords на GitHub и название репозитория где он хранится, получить их можно из ссылки на репозиторий - https://github.com/jburkhardt/RAdwords. Советую обновлять пакет как минимум раз в несколько месяцев, именно с таким интервалом Google релизит новую версию API Google Ads, и для того, что иметь доступ к новому функционалу необходимо обновлять пакет, обновляется пакет точно так же как и устанавливается, с помощью приведённого выше кода. Теперь давайте перейдём к функциям пакета RAdwords, для того что бы получить список отчётов доступных в какой либо версии API можно воспользоваться функцией reports, для загрузки списка полей, доступных в каком либо отчёте есть функция metrics. library(RAdwords) reports(apiVersion = &quot;201806&quot;) # список доступных отчётов ## [1] &quot;ACCOUNT_PERFORMANCE_REPORT&quot; ## [2] &quot;AD_CUSTOMIZERS_FEED_ITEM_REPORT&quot; ## [3] &quot;AD_PERFORMANCE_REPORT&quot; ## [4] &quot;ADGROUP_PERFORMANCE_REPORT&quot; ## [5] &quot;AGE_RANGE_PERFORMANCE_REPORT&quot; ## [6] &quot;AUDIENCE_PERFORMANCE_REPORT&quot; ## [7] &quot;AUTOMATIC_PLACEMENTS_PERFORMANCE_REPORT&quot; ## [8] &quot;BID_GOAL_PERFORMANCE_REPORT&quot; ## [9] &quot;BUDGET_PERFORMANCE_REPORT&quot; ## [10] &quot;CALL_METRICS_CALL_DETAILS_REPORT&quot; ## [11] &quot;CAMPAIGN_AD_SCHEDULE_TARGET_REPORT&quot; ## [12] &quot;CAMPAIGN_CRITERIA_REPORT&quot; ## [13] &quot;CAMPAIGN_GROUP_PERFORMANCE_REPORT&quot; ## [14] &quot;CAMPAIGN_LOCATION_TARGET_REPORT&quot; ## [15] &quot;CAMPAIGN_NEGATIVE_KEYWORDS_PERFORMANCE_REPORT&quot; ## [16] &quot;CAMPAIGN_NEGATIVE_LOCATIONS_REPORT&quot; ## [17] &quot;CAMPAIGN_NEGATIVE_PLACEMENTS_PERFORMANCE_REPORT&quot; ## [18] &quot;CAMPAIGN_PERFORMANCE_REPORT&quot; ## [19] &quot;CAMPAIGN_SHARED_SET_REPORT&quot; ## [20] &quot;CLICK_PERFORMANCE_REPORT&quot; ## [21] &quot;CREATIVE_CONVERSION_REPORT&quot; ## [22] &quot;CRITERIA_PERFORMANCE_REPORT&quot; ## [23] &quot;DESTINATION_URL_REPORT&quot; ## [24] &quot;DISPLAY_KEYWORD_PERFORMANCE_REPORT&quot; ## [25] &quot;DISPLAY_TOPICS_PERFORMANCE_REPORT&quot; ## [26] &quot;FINAL_URL_REPORT&quot; ## [27] &quot;GENDER_PERFORMANCE_REPORT&quot; ## [28] &quot;GEO_PERFORMANCE_REPORT&quot; ## [29] &quot;KEYWORDLESS_CATEGORY_REPORT&quot; ## [30] &quot;KEYWORDLESS_QUERY_REPORT&quot; ## [31] &quot;KEYWORDS_PERFORMANCE_REPORT&quot; ## [32] &quot;LABEL_REPORT&quot; ## [33] &quot;LANDING_PAGE_REPORT&quot; ## [34] &quot;MARKETPLACE_PERFORMANCE_REPORT&quot; ## [35] &quot;PAID_ORGANIC_QUERY_REPORT&quot; ## [36] &quot;PARENTAL_STATUS_PERFORMANCE_REPORT&quot; ## [37] &quot;PLACEHOLDER_FEED_ITEM_REPORT&quot; ## [38] &quot;PLACEHOLDER_REPORT&quot; ## [39] &quot;PLACEMENT_PERFORMANCE_REPORT&quot; ## [40] &quot;PRODUCT_PARTITION_REPORT&quot; ## [41] &quot;SEARCH_QUERY_PERFORMANCE_REPORT&quot; ## [42] &quot;SHARED_SET_CRITERIA_REPORT&quot; ## [43] &quot;SHARED_SET_REPORT&quot; ## [44] &quot;SHOPPING_PERFORMANCE_REPORT&quot; ## [45] &quot;TOP_CONTENT_PERFORMANCE_REPORT&quot; ## [46] &quot;URL_PERFORMANCE_REPORT&quot; ## [47] &quot;USER_AD_DISTANCE_REPORT&quot; ## [48] &quot;VIDEO_PERFORMANCE_REPORT&quot; metrics(report = &quot;CAMPAIGN_PERFORMANCE_REPORT&quot;, apiVersion = &quot;201806&quot;) ## [1] AccountCurrencyCode ## [2] AccountDescriptiveName ## [3] AccountTimeZone ## [4] ActiveViewCpm ## [5] ActiveViewCtr ## [6] ActiveViewImpressions ## [7] ActiveViewMeasurability ## [8] ActiveViewMeasurableCost ## [9] ActiveViewMeasurableImpressions ## [10] ActiveViewViewability ## [11] AdNetworkType1 ## [12] AdNetworkType2 ## [13] AdvertisingChannelSubType ## [14] AdvertisingChannelType ## [15] AllConversionRate ## [16] AllConversions ## [17] AllConversionValue ## [18] Amount ## [19] AverageCost ## [20] AverageCpc ## [21] AverageCpe ## [22] AverageCpm ## [23] AverageCpv ## [24] AverageFrequency ## [25] AveragePageviews ## [26] AveragePosition ## [27] AverageTimeOnSite ## [28] BaseCampaignId ## [29] BiddingStrategyId ## [30] BiddingStrategyName ## [31] BiddingStrategyType ## [32] BounceRate ## [33] BudgetId ## [34] CampaignDesktopBidModifier ## [35] CampaignGroupId ## [36] CampaignId ## [37] CampaignMobileBidModifier ## [38] CampaignName ## [39] CampaignStatus ## [40] CampaignTabletBidModifier ## [41] CampaignTrialType ## [42] ClickAssistedConversions ## [43] ClickAssistedConversionsOverLastClickConversions ## [44] ClickAssistedConversionValue ## [45] Clicks ## [46] ClickType ## [47] ContentBudgetLostImpressionShare ## [48] ContentImpressionShare ## [49] ContentRankLostImpressionShare ## [50] ConversionCategoryName ## [51] ConversionLagBucket ## [52] ConversionRate ## [53] Conversions ## [54] ConversionTrackerId ## [55] ConversionTypeName ## [56] ConversionValue ## [57] Cost ## [58] CostPerAllConversion ## [59] CostPerConversion ## [60] CostPerCurrentModelAttributedConversion ## [61] CrossDeviceConversions ## [62] Ctr ## [63] CurrentModelAttributedConversions ## [64] CurrentModelAttributedConversionValue ## [65] CustomerDescriptiveName ## [66] Date ## [67] DayOfWeek ## [68] Device ## [69] EndDate ## [70] EngagementRate ## [71] Engagements ## [72] EnhancedCpcEnabled ## [73] ExternalConversionSource ## [74] ExternalCustomerId ## [75] FinalUrlSuffix ## [76] GmailForwards ## [77] GmailSaves ## [78] GmailSecondaryClicks ## [79] HourOfDay ## [80] ImpressionAssistedConversions ## [81] ImpressionAssistedConversionsOverLastClickConversions ## [82] ImpressionAssistedConversionValue ## [83] ImpressionReach ## [84] Impressions ## [85] InteractionRate ## [86] Interactions ## [87] InteractionTypes ## [88] InvalidClickRate ## [89] InvalidClicks ## [90] IsBudgetExplicitlyShared ## [91] LabelIds ## [92] Labels ## [93] MaximizeConversionValueTargetRoas ## [94] Month ## [95] MonthOfYear ## [96] NumOfflineImpressions ## [97] NumOfflineInteractions ## [98] OfflineInteractionRate ## [99] PercentNewVisitors ## [100] Period ## [101] Quarter ## [102] RelativeCtr ## [103] SearchAbsoluteTopImpressionShare ## [104] SearchBudgetLostImpressionShare ## [105] SearchClickShare ## [106] SearchExactMatchImpressionShare ## [107] SearchImpressionShare ## [108] SearchRankLostImpressionShare ## [109] ServingStatus ## [110] Slot ## [111] StartDate ## [112] TotalAmount ## [113] TrackingUrlTemplate ## [114] UrlCustomParameters ## [115] ValuePerAllConversion ## [116] ValuePerConversion ## [117] ValuePerCurrentModelAttributedConversion ## [118] VideoQuartile100Rate ## [119] VideoQuartile25Rate ## [120] VideoQuartile50Rate ## [121] VideoQuartile75Rate ## [122] VideoViewRate ## [123] VideoViews ## [124] ViewThroughConversions ## [125] Week ## [126] Year ## 126 Levels: AccountCurrencyCode AccountDescriptiveName ... Year Для работы с API Google Ads вам для начала необходимо авторизоваться под каким либо Google аккаунтом, к которому привязан аккаунт Google Ads. Для авторизации вам необходимо использовать функцию doAuth(). При первом запуске этой функции будет открыт браузер, в котором вы выберите нужный аккаунт и подтвердите к нему доступ, при этом в рабочй директории будет создан файл .google.auth.RData, в котором будут хранится учётные данные для работы с API, в дальнейшем вам не придётся проходить авторизацию через браузер т.к. пакет будет запрашивать все необходимые для работы с API данные уже из локального файла. Формирование и отправка запроса на загрузку каких либо данных из API Google Ads осуществляется в два этапа, с помощью функции statement мы формируем запрос, и отправляем с помощью функции getData. # Составляем запрос body &lt;- statement(select = c(&quot;Date&quot;, &quot;CampaignName&quot;, &quot;Device&quot;, &quot;Clicks&quot;, &quot;Impressions&quot;, &quot;Cost&quot;), report = &quot;CAMPAIGN_PERFORMANCE_REPORT&quot;, where = &quot;Impressions &gt; 50&quot;, start = &quot;2018-07-01&quot;, end = &quot;2018-07-31&quot;) # Запрашиваем данные data &lt;- getData(clientCustomerId = &quot;123-456-7890&quot;, google_auth = ads_auth, statement = body, includeZeroImpressions = TRUE) 6.3 Работа с API Яндекс Директ Для работы с API Яндекс Директ в R есть пакет ryandexdirect, его функции позволяют вам выполнять следующие действия: Авторизовываться в API. Получать список различных объектов рекламного кабинета, рекламных кампаний, групп объявлений, объявлений, для агентских аккаунтов можно запрашивать список клиентов, и параметры каждого клиента. Управлять показами на уровне рекламных кампаний, групп объявлений и объявлений. Загружать статистику. Загружать справочную информацию. Для автоизации в API можно использовать функцию yadirAuth, но делать это необязательно т.к. при вызове любой из функций пакета изначально R ищет файл в котором хранятся учётные данные, и если не находит то вы автоматически переходите в браузер для прохождения процесса авторизации. 6.3.1 Пакет ryandexdirect Устанавливать пакет ryandexdirect рекомендую из моего репозитория на GitHub с помощью команды devtools::install_github('selesnow/ryandexdirect'). Для прохождения процесса авторизации в ryandexdirect существует функция yadirAuth, но отдельно вызывать её нет необходимости, т.к. при запуске любой из функций пакета, изначально запускается процесс поиска файла хранящего учётные данные, если такой файл функция не находит то автоматически запускается процесс авторизации. Все функции пакета содержат набор аргументов для работы с учётными данными: * Login - Логин на яндексе клиентского аккаунта, используется для авторизации под обычным, клиентским аккаунтом, а так же в названии файла в котором хранятся учётные данные. * AgencyAccount - Логин на яндексе для управляющего, агентского аккаунта, используется для авторизации под агентским аккаунтом, а так же в названии файла в котором хранятся учётные данные. * TokenPath - Путь к папке в которой вы храните файлы с учётными данными, при первом обращении к API из под какого либо аккаунта файл сохраняется в указанной папке, далее при работе с этим аккаунтом, функции пакета ищут его в указанной папке по аккаунту указанному в аргементе Login или AgencyAccount. * Token - Устаревший аргумент, не рекомендуемый к использованию, принимает токен доступа к API в виде строки, сохранён для воспроизведения кода написаного до версии 3.0.0. 6.3.1.1 Загрузка объектов из API Яндекс Директ Для загрузки различных объектов из рекламного кабинета Яндекс Директ в пакете ryandecdirect есть одноимённые функции: yadirGetCampaignList - Загрузка списка рекламных кампаний yadirGetAdGroups - Загрузка списка групп объявлений yadirGetKeyWords - Загрузка списка ключевых слов yadirGetSiteLinks - Загрузка списка быстрых ссылок yadirGetBalance - Загрузка параметров общего счёта library(ryandexdirect) setwd(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 3&quot;) # Запрос объектов рекламного аккаунта # Список рекламных кампаний my_camp &lt;- yadirGetCampaignList(Logins = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # Список групп объявлений my_group &lt;- yadirGetAdGroups(Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # Список ключевых слов my_keyw &lt;- yadirGetKeyWords(Login = &quot;netpeak.vyacheslav&quot;, States = &quot;ON&quot;, TokenPath = &quot;direct_tokens&quot;) # Список быстрых ссылок my_links &lt;- yadirGetSiteLinks(Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # Загрузка данных по общему счёту, ключая остаток balance &lt;- yadirGetBalance(Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) 6.3.1.2 Загрузка справочной информации из API Яндекс Директ Для загрузки справочной информации из API Яндекс Директ необхоимо использовать функцию yadirGetDictionary, передав в аргумент DictionaryName название справочника который хотите получить. Currencies - Курсы валют, валютные параметры и ограничения. MetroStations - Станции метрополитена (только для Москвы, Санкт-Петербурга и Киева). GeoRegions - Регионы. TimeZones - Часовые пояса. Constants - Ограничения на значения параметров. AdCategories - Особые категории рекламируемых товаров и услуг. OperationSystemVersions - Версии операционных систем для рекламы мобильных приложений. ProductivityAssertions - Параметр утратил актуальность и не возвращается. SupplySidePlatforms - Внешние сети (SSP). Interests - Интересы к категориям мобильных приложений. geo &lt;- yadirGetDictionary(DictionaryName = &quot;GeoRegions&quot;, Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) cur &lt;- yadirGetDictionary(DictionaryName = &quot;Currencies&quot;, Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) adcategories &lt;- yadirGetDictionary(DictionaryName = &quot;AdCategories&quot;, Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) constant &lt;- yadirGetDictionary(DictionaryName = &quot;Constants&quot;, Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) 6.3.1.3 Управление показами Помимо загрузки различных объектов из рекламного кабинета с помощью ryandexdirect вы можете останавливать и возобновлять показы на уровне рекламных кампаний, ключевых слов и объявлений. Для остановки показов необходимо воспользоваться одной из функций: * yadirStopCampaigns - Остановка показов на уровне рекламных кампаний * yadirStopKeyWords - Остановка показов на уровне ключевых слов * yadirStopAds - Остановка показов на уровне объявлений Возобновление показов осуществляется с помощью группы функций yadirStart: * yadirStartCampaigns - Возобновление показов на уровне рекламных кампаний * yadirStartKeyWords - Возобновление показов на уровне ключевых слов * yadirStartAds - Возобновление показов на уровне объявлений # Список рекламных кампаний my_camp &lt;- yadirGetCampaignList(Logins = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # Запуск и остановка показов # получаем список активных РК active_campaign_before &lt;- my_camp$Id[my_camp$State == &quot;ON&quot;] # остановка рекламных кампаний yadirStopCampaigns(Ids = c(30361157, 30361191), Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # получаем список активных РК my_camp_new &lt;- yadirGetCampaignList(Logins = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) active_campaign_after_stoped &lt;- my_camp_new$Id[my_camp_new$State == &quot;ON&quot;] # запускаем РК yadirStartCampaigns(Ids = c(30361157, 30361191), Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # получаем список активных РК my_camp_new2 &lt;- yadirGetCampaignList(Logins = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) active_campaign_after_start &lt;- my_camp_new$Id[my_camp_new2$State == &quot;ON&quot;] # сверяем со списком который был до остановки all.equal(active_campaign_before, active_campaign_after_start) В аргумент Id необходимо передавать вектор Id тех объектов по которым вы хотите запустить или остановить показы. 6.3.1.4 Загрузка статистики из API Яндекс Директ API интерфейс Reports в Яндекс Директ похож на Google Ads, так же состоит из отчётов и полей. На момент последнего редактирования данного конспекта в API ЯНдекс Директ существует 8 отчётов. ACCOUNT_PERFORMANCE_REPORT - Статистика по аккаунту рекламодателя CAMPAIGN_PERFORMANCE_REPORT - Статистика по кампаниям ADGROUP_PERFORMANCE_REPORT - Статистика по группам объявлений AD_PERFORMANCE_REPORT - Статистика по объявлениям CRITERIA_PERFORMANCE_REPORT - Статистика по условиям показа CUSTOM_REPORT - Статистика с произвольными группировками REACH_AND_FREQUENCY_PERFORMANCE_REPORT - Статистика по медийным кампаниям. Отчет содержит только данные по кампаниям с типом «Медийная кампания», кампании остальных типов игнорируются SEARCH_QUERY_PERFORMANCE_REPORT - Статистика по поисковым запросам Актуальный список отчётов можно найти по ссылке, список полей можно найти тут. Все поля поделены на 4 группы: фильтр — поле используется только для фильтрации данных и не может быть выведено в отчете; сегмент — при выводе в отчете поле используется для группировки данных; метрика — поле содержит числовое значение, рассчитанное в соответствии с заданными фильтрами и группировками; атрибут — поле содержит фиксированное значение в соответствии с заданными группировками, добавление такого поля в отчет не приводит к появлению новой группировки. Загрузка статистики осуществляется с помощью функции yadirGetReport, которая принимает следующие аргументы. ReportType - Тип отчёта DateRangeType - Отчётный период, принимает следующие значения (TODAY, YESTERDAY, LAST_3_DAYS, LAST_5_DAYS, LAST_7_DAYS, LAST_14_DAYS, LAST_30_DAYS, LAST_90_DAYS, LAST_365_DAYS, THIS_WEEK_MON_TODAY ,THIS_WEEK_SUN_TODAY, LAST_WEEK, LAST_BUSINESS_WEEK, LAST_WEEK_SUN_SAT, THIS_MONTH, LAST_MONTH, ALL_TIME, CUSTOM_DATE, AUTO) DateFrom и DateTo - Дата начала и завершения отчётного перода, используется только если в аргумент DateRangeType установлено значение CUSTOM_DATE. FieldNames - Список полей отчёта. FilterList - Вектор содержащий условия фильтрации, пример c(&quot;Clicks GREATER_THAN 99&quot;,&quot;Impressions LESS_THAN 1000&quot;). IncludeVAT - Учитывать в расчёте трат НДС или нет. IncludeDiscount - Учитывать в расчёте трат скидку или нет. Login - Логин клиентского аккаунта. AgencyAccount - Логин агентского аккаунта, используется только при работе с агентским аккаунтом. TokenPath - Путь к папке в которую будет созранён файл с учётными данными, либо где уже есть данный файл. Пример загрузки данных из обычного, клиентского аккаунта: # Загрузка статистики # Работа с обычным рекламным аккаунтом # Статистика по рекламным кампаниям за пользовательский период с применением фильтра my_camp_stat &lt;- yadirGetReport(ReportType = &quot;CAMPAIGN_PERFORMANCE_REPORT&quot;, DateRangeType = &quot;CUSTOM_DATE&quot;, DateFrom = &quot;2018-07-01&quot;, DateTo = &quot;2018-07-31&quot;, FieldNames = c(&quot;Date&quot;, &quot;CampaignId&quot;, &quot;Clicks&quot;), FilterList = c(&quot;Clicks GREATER_THAN 1&quot;,&quot;Impressions LESS_THAN 1000&quot;), IncludeVAT = &quot;YES&quot;, IncludeDiscount = &quot;NO&quot;, Login = &quot;netpeak.vyacheslav&quot;, TokenPath = &quot;direct_tokens&quot;) # Статистика за прошлую рабочую неделю my_daily_stat &lt;- yadirGetReport(ReportType = &quot;CUSTOM_REPORT&quot;, DateRangeType = &quot;LAST_BUSINESS_WEEK&quot;, FieldNames = c(&quot;Date&quot;, &quot;Clicks&quot;, &quot;Impressions&quot;), Login = &quot;netpeak.vyacheslav&quot;, IncludeVAT = &quot;YES&quot;, IncludeDiscount = &quot;NO&quot;, TokenPath = &quot;direct_tokens&quot;) Для работы с агентским аккаунтом вам необходимо указать в аргументе AgencyAccount логин агентского аккаунта, в аругмент Login логин клиентского аккаунта из которого вы хотите загрузить данные. При работе с агентским аккаунтом в аргумент Login можно передавать вектор содержащий логини клиентских аккаунтов, загрузить список клиентов можно с помощью функции yadirGetClientList, загрузить дополнительные параметры клиентов из агентского аккаунта можно с помощью функции yadirGetClientParam. # Работа с агентским рекламным аккаунтом # загрузка списка клиентов my_client &lt;- yadirGetClientList(AgencyAccount = &quot;netpeak.kz&quot;, TokenPath = &quot;direct_tokens&quot;) # Загрузка данных о стране клиента, валюте аккаунта, оценка показателя качества аккаунтаа my_cl_param &lt;- yadirGetClientParam(AgencyAccount = &quot;netpeak.kz&quot;, TokenPath = &quot;direct_tokens&quot;) # загрузка статистики по клиентам my_client_stat &lt;- yadirGetReport(ReportType = &quot;CUSTOM_REPORT&quot;, DateRangeType = &quot;LAST_BUSINESS_WEEK&quot;, FieldNames = c(&quot;Clicks&quot;, &quot;Impressions&quot;), AgencyAccount = &quot;netpeak.kz&quot;, Login = my_client$Login[5:11], IncludeVAT = &quot;YES&quot;, IncludeDiscount = &quot;NO&quot;, TokenPath = &quot;direct_tokens&quot;) 6.4 Работа с API Facebook Для работы с API Facebook мною был разработан пакет rfacebookstat, функции данного пакета позволяют. Загружать объекты из рекламного кабинета Facebook. Загружать статистику из рекламных кабинетов Facebook. Управлять доступами к реламным кабинетам Facebook. Установить пакет rfacebookstat можно как из моего репозитория на GitHub, так и из основного репозитория CRAN. Установка с GitHub - devtools::install_github('selesnow/rfacebokstat') Установка с CRAN - install.packages('rfacebookstat') 6.4.1 Создание приложения в Facebook Для доступа к API Facebook вам необходимо создать приложение в веб интерфейсе Facebook. 1, В основном меню Facebook выберите пункт “Управление приложениями” или перейдите по этой ссылке. Создание приложения в Facebook Нажмите кнопку “Добавить новое приложение”, которая находится в правом верхнем углу. Заполните поля в открывшемся дилоговом окне “Создайте ID приложения” и нажмите кнопку ЭСоздайте ID приложения&quot; Добавьте продукты “API Marketing” и “Вход через Facebook” Добавление продуктов В настройка продукта “Вход через Facebook” установите в качестве Действительные URI перенаправления для OAuth ссылку - https://selesnow.github.io/rfacebookstat/getToken/get_token.html 6.4.2 Авторизация в API Facebook Для прохождения процесса авторизации в API Facebook вам необходимо использовать 2 функции: fbGetToken - Для получения краткосрочного токена. fbGetLongTimeToken - Для обмена кратсрочного токена на долгосрочный. В качестве аргументов вам понадобится информация по идентификатору и секрету созданного на прошлом шаге приложения, найти эту информацию можно в его настройках, перейдя в меню “Основное.” # авторизация в API # краткосрочный токен my_st_token &lt;- fbGetToken(app_id = 1672451129546934) # долгосрочный токен fb_token &lt;- fbGetLongTimeToken(client_id = 1672451129546934, client_secret = &quot;a6c01acdb9a4100216de5f8874adbce5&quot;, fb_exchange_token = my_st_token) # Сохраняем токен save(file = &quot;fb_token.RData&quot;) Таким образом мы авторизовались в API, поменяли краткосрочный токен на долгосрочный, и сохранили его в рабочей директории в файл fb_token.RData. 6.4.3 Загрузка объектов из рекламного кабинета Facebook Для загрузки различных объектов из рекламного кабинета в пакете rfacebookstat существуют одноимённые функции. 6.4.3.1 Загрузка объектов из бизнес менеджера fbGetBusinessManagers - Загрузка списка доступных бизнес менеджеров fbGetProjects - Загрузка списка проектов из бизнес менеджера fbGetAdAccounts - Загрузка списка рекламных аккаунтов fbGetPages - Загрузка списка продвигаемых страниц из проектоа fbGetApps - Загрузка списка приложений Аргументы которые встречаются в функциях для загрузки объектов из бизнес менеджера: access_token - Токен полученный при авторизации в API bussiness_id - ID бизнес менеджера source_id - ID бизнес менеджера или проекта projects_id - ID проекта Пример # бизнес менеджеры my_fb_bm &lt;- fbGetBusinessManagers(access_token = fb_token) # проекты из бизнес менеджера my_fb_proj &lt;- fbGetProjects(bussiness_id = my_fb_bm$id, access_token = fb_token) # рекламные аккаунты my_fb_acc &lt;- fbGetAdAccounts(source_id = my_fb_bm$id, access_token = fb_token) # страницы my_fb_page &lt;- fbGetPages(projects_id = my_fb_proj$id, access_token = fb_token) # приложения my_fb_apps &lt;- fbGetApps(projects_id = my_fb_proj$id, access_token = fb_token) 6.4.3.2 Загрузка объектов из рекламного аккаунта fbGetCampaigns - Загрузка списка рекламных кампаний fbGetAdSets - Загрузка списка групп объявлений fbGetAds -Загрузка списка объявлений fbGetAdCreative - Загрузка контента объявлений Аргументы которые встречаются в функциях для загрузки объектов из рекламного аккаунта: accounts_id - ID рекламного кабинета, в формате act_00000000000 access_token - Токен полученный при авторизации в API Пример # Объекты рекламного аккаунта # кампании my_fb_camp &lt;- fbGetCampaigns(accounts_id = &quot;act_262115113&quot;, access_token = fb_token) # группы объявлений my_fb_adsets &lt;- fbGetAdSets(accounts_id = &quot;act_262115113&quot;, access_token = fb_token) # объявления my_fb_ads &lt;- fbGetAds(accounts_id = &quot;act_262115113&quot;, access_token = fb_token) # контент объявлений my_fb_ad_content &lt;- fbGetAdCreative(accounts_id = &quot;act_262115113&quot;, access_token = fb_token) 6.4.3.3 Загрузка статистики из рекламного аккаунта Facebook Статистику из рекламного кабинета можно получить с помощью функции fbGetMarketingStat. Аргументы доступные в функции fbGetMarketingStat: accounts_id — ID рекламного аккаунта. Это обязательный аргумент. Вы можете получить его из URL, если перейдете в нужный рекламный аккаунт Facebook, указывайте ID аккаунта с приставкой «act_», как в примере: accounts_id = “act_000000000000”. sorting — cортировка данных. Необязательный аргумент. На входе принимает список полей и направление сортировки (по возрастанию или по убыванию). Пример: reach_descending, impressions_ascending. level — уровень детализации данных. Обязательный аргумент. Принимает значения ad, adset, campaign, account. Пример — level = “account”. fields — список полей, по которым вы планируете получить данные. Обязательный аргумент. Пример: fields = “account_id,account_name,campaign_name,impressions,unique_impressions,clicks,unique_clicks,reach,spend”. Актуальный список всех доступных полей можно посмотреть в официальной документации к API по ссылке. filtering — фильтр данных. Необязательный аргумент. Фильтры задаются в виде JSON объектов «ключ:значение». Необходимо прописать три свойства: field — поле, по которому будет осуществляться фильтрация; operator — оператор логического значения (‘EQUAL’, ‘NOT_EQUAL’, ‘GREATER_THAN’, ‘GREATER_THAN_OR_EQUAL’, ‘LESS_THAN’, ‘LESS_THAN_OR_EQUAL’, ‘IN_RANGE’, ‘NOT_IN_RANGE’, ‘CONTAIN’, ‘NOT_CONTAIN’, ‘IN’, ‘NOT_IN’, ‘ANY’, ‘ALL’, ‘NONE’); value — значения, по которому будет фильтроваться указанное поле. Пример: filtering = “[{‘field’:‘publisher_platform’,‘operator’:‘IN’,‘value’:[‘instagram’]}] breakdowns — аргумент, с помощью которого можно получить данные в разбивке на различные сегменты. Список доступных срезов информации, а так же информацию о том как они могут друг с другом сочитаться можно посмотреть в официальной документации к API по ссылке. date_start — начальная дата отчетного периода в формате YYYY-MM-DDD. date_stop — конечная дата отчетного периода в формате YYYY-MM-DDD. interval - временная разбивка, допустимые значения “day”, “week”, “month”, “quarter”, “year”, “overall” console_type - текстовое значение, тип ответов в консоли, принимает одно из двух значений: progressbar (по умолчанию) - для вывода в консоли прогресс бара, отображающего % загруженных даных. message - для вывода сообщений о процессе загрузки, например вывод сообщений о том, что был запущен механизм обхода пользовательского лимита на количество допустимых запросов к API Facebook. request_speed - скорость оправки запросов к API, в зависимости от уровня доступа вашего приложения установите следующее значение: Уровень доступа к API Development - “slow” Уровень доступа к API Basic - “normal” Уровень доступа к API Standart - “fast” Подробно работа с этим аргументом описана тут. Информация об уровнях доступа к API Facebook находится тут. api_version — версия API Facebook, в формате v., например “v3.1” access_token — токен доступа. Пример my_fb_stats &lt;- fbGetMarketingStat(accounts_id = &quot;act_262115113&quot;, level = &quot;campaign&quot;, fields = &quot;account_name,campaign_name,impressions,clicks&quot;, breakdowns = &quot;device_platform&quot;, date_start = &quot;2018-08-01&quot;, date_stop = &quot;2018-08-07&quot;, interval = &quot;day&quot;, access_token = fb_token) 6.4.3.4 Управление списком пользователей и доступами к рекламного аккаунта Facebook fbGetAdAccountUsers - Получить список пользователей из рекламного аккаунта fbDeleteAdAccountUsers - Удалить пользователя рекламого аккаунта fbUpdateAdAccountUsers - Добавить пользователя в рекламный аккаунт. Аргументы accounts_id - ID рекламного аккаунта в формате act_0000000000 access_token - Токен доступа к API Facebook user_ids - ID пользователя role - Роль, которая определяет набор порав, которые будут у пользователя рекламного аккаунта, возможные значения: administator, advertiser, ad manager, analyst, sales, direct sales. Подробнее о полях можно узнать по ссылке. Пример # управление пользователями # загрузка списка пользоватеелей fb_acc_user &lt;- fbGetAdAccountUsers(accounts_id = &quot;act_262115113&quot;, access_token = fb_token, console_type = &quot;message&quot;) # удаление пользователя с ID 823041644481205 fbDeleteAdAccountUsers(user_ids = &quot;823041644481205&quot;, accounts_id = &quot;act_262115113&quot;, access_token = fb_token, api_version = &quot;v3.1&quot;) # загрузка списка пользоватеелей fb_acc_user2 &lt;- fbGetAdAccountUsers(accounts_id = &quot;act_262115113&quot;, access_token = fb_token, console_type = &quot;message&quot;) # сравнение списка пользователей до и после удаления пользователя с ID 823041644481205 all.equal(fb_acc_user, fb_acc_user2) # добавление пользователя fbUpdateAdAccountUsers(user_ids = &quot;823041644481205&quot;, accounts_id = &quot;act_262115113&quot;, role = &quot;advertiser&quot;, access_token = fb_token) 6.5 Работа с API Вконтакте (vk.com) Для работы с API Вконтакте необходимо установить пакет rvkstat, на данный момент пакет доступен только из моего репозитория на GitHub, для установки воспользуйтесь командой devtools::install_github('selesnow/rvkstat'). 6.5.1 Создание приложения для работы с API Вконтакте Для создания приложения перейдите по этой ссылке, и выберите в разделе платформа Веб-сайт, если вы планируете загрузить диалоги из сообщества выбирайте - Standalone-приложение. Далее, если вы создали веб приложение перейдите в меню настроек приложения, и влючите Open API: После чего появятся настройки Open API, введите в них следующие значения: Адрес сайта: http://selesnow.github.io Адрес сайта: selesnow.github.io Доверенный redirect URI: https://selesnow.github.io/rvkstat/getCode/get_code.html Доверенный redirect URI: https://selesnow.github.io/rvkstat/getCode/get_token.html Доверенный redirect URI: https://oauth.vk.com/blank.html Для начала работы с функциями пакета и для того, что бы с помощью формы получения токена или функции авторизации в Вконтакте получить токен разработчика используйте ID и Защищённый ключ приложения, вы в любой момент сможете найти их в настройках вашего приложения. ID и секрет приложения 6.5.2 Авторизация в API Вконтакте Для прохождения авторизации в rvkstat есть несколько функций, но рекомендуется использовать vkAuth. myToken &lt;- vkAuth(app_id = &lt;ID Вашего Приложения&gt;, app_secret = &lt;Защищённый Ключ Вашего Приложения&gt;) 6.5.3 Функции пакета rvkstat Все функции пакета поделены на 4 группы, определить к какой группе относится функция можно из её названия, название группы к которой относится функция идёт сразу после префикса vk: GetGroupStat - загрузка статистики по сообществам Вконтакте. GetAd - загрузка данных из рекламного кабинета Вконтакте. GetDb - загрузка справочной информации из Вконтакте. GetUser - загрузка данных о конкретном пользователе Вконтакте. 6.5.4 Загрузка объектов из рекламного кабинета Вконтакте vkGetAdCategories - получить справочник тематик рекламных объявлений vkGetAdAccounts - получить список рекламных аккаунтов vkGetAdClients - получить список клиентов из агентского аккаунта vkGetAdCampaigns - получить список рекламных кампаний vkGetAds - получить список объявлений vkGetAdsLayout - получить внешний вид объявлений Аргументы функций для работы с рекламным кабинетом: access_token - токен доступа к API, полученный с помощью функции vkAuth account_id - id рекламного кабинета client_id - id клиентского реклманого кабинета, при работе через агентский аккаунт Пример vk_auth &lt;- vkAuth(app_id = 6656352, app_secret = &quot;wSGrZuNEs1D4RbffGKDY&quot;) # работа с рекламнымы аккаунтами # получить справочник тематик рекламных объявлений category &lt;- vkGetAdCategories(access_token = vk_auth$access_token, api_version = &quot;5.73&quot;) # получить список рекламных аккаунтов vk_acc &lt;- vkGetAdAccounts(access_token = vk_auth$access_token) # получить список клиентов из агентского аккаунта vk_client &lt;- vkGetAdClients(account_id = 1900000891, access_token = vk_auth$access_token, api_version = &quot;5.73&quot;) # получить список рекламных кампаний vk_camp &lt;- vkGetAdCampaigns(account_id = 1900000891, client_id = 1602773233, access_token = vk_auth$access_token) # получить список объявлений vk_ads &lt;- vkGetAds(account_id = 1900000891, client_id = 1602773233, access_token = vk_auth$access_token) # внешний вид объявлений vk_ad_layout &lt;- vkGetAdsLayout(account_id = 1900000891, client_id = 1602773233, access_token = vk_auth$access_token) 6.5.5 Загрузка статистики из рекламного кабинета Вконтакте Получить статистические данные из рекламного кабинета Вконтакте можно с помощью функции vkGetAdStatistics. Аргументы функции vkGetAdStatistics account_id - Идентификатор рекламного кабинета, список всех доступных рекламных кабинетов можно получить с помщью функции vkGetAdAccounts. ids_type - Тип запрашиваемых объектов, которые перечислены в параметре ids, допустимые значения: ad — объявления campaign — кампании client — клиенты office — кабинет ids - Перечисленные через запятую id запрашиваемых объявлений, кампаний, клиентов или кабинета, в зависимости от того, что указано в параметре ids_type. period - Способ группировки данных по датам, допустимые значения: day — статистика по дням month — статистика по месяцам overall — статистика за всё время date_from - Начальная дата выводимой статистики. Используется разный формат дат для разного значения параметра period day: YYYY-MM-DD, пример: 2011-09-27 - 27 сентября 2011 month: YYYY-MM, пример: 2011-09 - сентябрь 2011 overall: 0 date_to - Конечная дата выводимой статистики. Используется разный формат дат для разного значения параметра period: day: YYYY-MM-DD, пример: 2011-09-27 - 27 сентября 2011 month: YYYY-MM, пример: 2011-09 - сентябрь 2011 overall: 0 api_version - Версия API к который вы будете обращаться, список актуальных версий доступен по ссылке. access_token - Токен доступа к API, полученный с помощью функций vkAuth Пример # Статистика рекламного кабинета camp_stat &lt;- vkGetAdStatistics(account_id = 1900000891, ids = vk_camp$id, ids_type = &quot;campaign&quot;, period = &quot;day&quot;, date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, access_token = vk_auth$access_token) # Статистика по клиентам агентского аккаунта client_stat &lt;- vkGetAdStatistics(account_id = 1900000891, ids = vk_client$id, ids_type = &quot;client&quot;, period = &quot;month&quot;, date_from = &quot;2018-01-01&quot;, date_to = &quot;2018-08-08&quot;, access_token = vk_auth$access_token, api_version = &quot;5.73&quot;) 6.5.6 Загрузка статистики по сообществам и группам Вконтакте Функции для работы со статистикой сообществ Вконтакте: vkGetUserGroups - Список групп пользователя vkGetGroupStat - Общая статистика по сообществу vkGetGroupStatAge - Статистика по посетителям сообщества в разбивке по возрасту vkGetGroupStatGender - Статистика по посетителям сообщества в разбивке по полу vkGetGroupStatGenderAge - Статистика по посетителям сообщества в разбивке по полу и возрасту vkGetGroupStatCity - Статистика по посетителям сообщества в разбивке по городам vkGetGroupStatCountries - Статистика по посетителям сообщества в разбивке по странам Аргументы date_from - начальная дата отчётного периода date_to - конечная дата отчётного периода group_id - id сообщества по которому хотите получить статистику access_token - токен полученный с помощью функции vkAuth Пример # статистика сообщества # получить список всех групп пользователя my_groups &lt;- vkGetUserGroups(access_token = vk_auth$access_token) # общаяя статистика по сообществу gr_stat &lt;- vkGetGroupStat(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) # статистика по посетителям сообщества в разбивке по возрасту gr_stat_age &lt;- vkGetGroupStatAge(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) # статистика по посетителям сообщества в разбивке по полу gr_stat_gender &lt;- vkGetGroupStatGender(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) # статистика по посетителям сообщества в разбивке по полу и возрасту gr_stat_gen_age &lt;- vkGetGroupStatGenderAge(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) # статистика по посетителям сообщества в разбивке по городам gr_stat_city &lt;- vkGetGroupStatCity(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) # статистика по посетителям сообщества в разбивке по странам gr_stat_country &lt;- vkGetGroupStatCountries(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-08&quot;, group_id = 119709976, access_token = vk_auth$access_token) 6.6 Работа с API MyTarget Для работы с API интерфейсом рекламной платформы MyTarget вам необходимо установить пакет rmytarget, данный пакет пока доступен только для установки из моего репозитория на GitHub, для усатановки выполните команду devtools::install_github(&quot;selesnow/rmytarget&quot;). В rmytarget на данный момент всего 4 основные функции: myTarGetCampaignList - Загрузка списка рекламных кампаний myTarGetAdList - Загрузка списка объявлений myTarGetStats - Загрузка статистики по рекламным кампаниям или ообъявлениям myTarGetClientList - Загрузка списка клиентов из агентского аккаунта 6.6.1 Авторизация в API MyTarget Процесс авторизации запускается при первом запуске любой из доступных в пакете функций, и состоит из следующих этапов: При запуске любой функции изначально начинается поиск в папке указанной в агрументе token_path, локального файла содержащего в себе учётные данные, поиск файла осуществляется по его названию login.mytar.Auth.RData, где вместо login будет подставлено значеник указанное вами в аргументе login. Если файл login.mytar.Auth.RData, в котором хранятся учётные данные был найден в указанной в аргументе token_path директории то запущенная функция загрузит из него необходимые для авторизации данные и продолжит работу по загрузке данных. Если файл login.mytar.Auth.RData, в котором хранятся учётные данные не был найден в указанной в аргументе token_path директории то будет запущен браузер, в котором вам необходимо подтвердить доступ rmytarget к одному из ваших аккаунтов в MyTarget. Далее вы будете перенаправлены на веб страницу на которой будет сгенерирован код подтверждения авторизации. Этот код необходимо скопировать и вставить в R консоль в ответ на запрос “Enter code from browser:”. Далее в консоли будет выведено сообщение “Do you want save API credential in local file (token_path/login.mytar.Auth.RData) for use it between R sessions?”, в качестве отвта на который вам необходимо ввести “y” или “yes”. После чего полученные учётные данные будут сохранены в директории указанной в аргументе token_path в файле login.mytar.Auth.RData, где вместо login будет подставлено значеник указанное вами в аргументе login. При следующем обращении к API с использованием любой из функций пакета авторизация будет проходить согласно пункту 1. Внимание API MyTarget даёт вам возможность получить максимум 5 токнов для одновременной работы на 1 аккаунт, т.е. если вы работаете под агентским аккаунтом то вы можете получить 5 токенов для самого агентского аккаунта, и по 5 токенов для каждого привязанного клиентского аккаунта, поэтому всегда сохраняйте учётные данные в файл, иначе возможна ситуация когда вы не сможете пройти авторизацию в API. В случае утери всех 5 токенов. Токены автоматически удаляются по истечении месяца неактивности (истечения expires_in), поэтому в случае когда вы получили все 5 токенов, и потеряли их запросить новый вы сможете не ранее чем через месяц после последнего обращения к API с помощью одного из утерянных токенов. Пример library(rmytarget) # обычный рекламный кабинет # загрузка объектов из рекламного кабинета camp &lt;- myTarGetCampaignList(login = &quot;client_account&quot;, token_path = &quot;tokens&quot;) ads &lt;- myTarGetAdList(login = &quot;client_account&quot;, token_path = &quot;tokens&quot;) # загрузка статистики # статистика по рекламным кампаниям camp_stat &lt;- myTarGetStats(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-31&quot;, object_id = camp$id, object_type = &quot;campaigns&quot;, login = &quot;client_account&quot;, token_path = &quot;tokens&quot;) # статистика по объявлениям ad_stats &lt;- myTarGetStats(date_from = &quot;2018-08-01&quot;, date_to = &quot;2018-08-31&quot;, object_id = ads$id, object_type = &quot;banners&quot;, login = &quot;client_account&quot;, token_path = &quot;tokens&quot;) # агентский рекламный кабинет clients &lt;- myTarGetClientList(login = &quot;agency_account&quot;, token_path = &quot;tokens&quot;) 6.7 Загрузка данных из Google Analytics Для работы с API в R существует несколько пакетов, я пробовал работать как минимум с четырмя, но наиболее удобным и многофункциональным для меня был пакет RGA разработанный Артёмом Клевцовым. Для установки воспользуйтесь командой install.packages(&quot;RGA&quot;). 6.7.1 Какие API интерфейсы доступны в Google Analytics В Google Analytics доступно 5 API интерфейсов. Core Reporting API - Запрашивайте параметры и показатели для создания специальных отчетов. Management API - Просматривайте аккаунты, свойства, представления, фильтры, разрешения и т. д. и управляйте ими. Multi-Channel Funnels Reporting API - Получайте отчеты по многоканальным последовательностям для анализа сложных путей конверсии. Real Time Reporting API - Получайте отчеты в режиме реального времени, чтобы знать, что происходит на вашем ресурсе прямо сейчас. Metadata API - Просматривайте список параметров, показателей, а также их атрибутов. 6.7.2 Авторизация в API Google Analytics При работе с пакетом RGA вы, в ходе одной R сессии, можете обращаться ко множеству Google аккаунтов, эо может понадобится если вам необходимо загрузить данные более чем из 100 аккаунтов Google Analytics т.к. существует ограничение 100 аккаунтов Analytics на одного пользователя. Для работы сразу под несколькими пользователями вы можете с помощью функции authorize и аргумента username авторизоваться под несколькими пользователями, при этом учётные данные каждого пользователя будут сохранены в локальные файлы, название файла будет выглядеть как .username*@gmail.com-token.rds, где username* будет аналогичен значению указанному в аргументе username. Пример авторизации под несколькими аккаунтами. r.for.marketing &lt;- authorize(username = &quot;r.for.marketing&quot;) alsey.netpeak &lt;- authorize(username = &quot;alsey.netpeak&quot;) 6.7.3 Работа с Management API Основные функции для работы с Management API list_accounts - Загрузка списка доступных аккаунтов для пользователя list_profiles - Загрузка списка доступных представлений list_webproperties - Загрузка списка доступных ресурсов list_goals - Загрузка списка настроенных целей list_filters - Загрузка списка фильтров list_segments - Загрузка списка сегментов Основные аргументы перечисленных выше функций accountId - Id аккаунта Google Analytics webPropertyId - Id представления Google Analytics profileId - Id ресурса Google Analytics token - Объект созданный с помощью функции authorize хранящий учётный данные Пример my_ga_accounts &lt;- RGA::list_accounts() # загрузка списка аккаунтов my_ga_profiles &lt;- RGA::list_profiles() # загрузка списка ресурсов my_ga_views &lt;- RGA::list_webproperties() # загрузка списка представлений my_goals &lt;- RGA::list_goals() # загрузка списка целей my_filters &lt;- RGA::list_filters(accountId = 44472206) # список фильтров my_segments &lt;- RGA::list_segments() # загрузка списка сегментов 6.7.4 Работа с Core Reporting API Функция get_ga позволяет вам запрашивать данные из Core Reporting API, её основные аргументы: profileId - Id представления Google Analytics start.date - Дата начала отчётного периода end.date - Дата окончания периода metrics - Список метрик отчёта, актуальный список доступен по ссылке dimensions - Список группировок отчёта, актуальный список доступен по ссылке sort - Сортировка отчёта, поля по которым необходимо отсортировать данные, для сортировки по убыванию перед названияем поля необходимо поставить минус filters - Условия фильтрации, смотрите пример кода операторы при фильтрации: == - точное соответсвие != - Не соответствует =@ - содержит подстроку !@ - не содержит подстроку =~ - соответсвуе регулярному выражени !~ - не соответвует регулярному выражению segment - Применить сегмент, вы можете либо описать динамический сегмент, либо указать Id нуюного сегмента, смотрите пример кода ниже samplingLevel - Уровень семплирования, для наибольшей точности данных укажите “HIGHER_PRECISION” fetch.by - Аргумент позволяющий разбить ваш запрос на подзапросы по времни, для обхода семплирования, принимает значения “day”, “week”, “month” token - Объект созданный с помощью функции authorize хранящий учётный данные Пример # Core API my_core_data &lt;- RGA::get_ga(profileId = &quot;ga:170507937&quot;, start.date = &quot;14daysAgo&quot;, end.date = &quot;yesterday&quot;, metrics = &quot;ga:users,ga:sessions,ga:bounces&quot;, dimensions = &quot;ga:date,ga:source,ga:medium&quot;, sort = &quot;-ga:date&quot;, filters = &quot;ga:medium!=cpc,ga:source=@g&quot;, # &quot;,&quot; - ИЛИ, &quot;;&quot; - И segment = &quot;sessions::condition::ga:bounces&gt;0&quot;, samplingLevel = &quot;HIGHER_PRECISION&quot;, fetch.by = &quot;day&quot;, token = alsey.netpeak) 6.7.5 Работа с Multi-Channel Funnels API Для загрузки цепочек взаимодействия пользователя на пути к совершению конверсии через Multi-Channel Funnels API вы должны использовать функцию get_mcf. Аргументы profileId - Id представления Google Analytics start.date - Дата начала отчётного периода, статичная или относительная, смотрите пример кода ниже end.date - Дата окончания отчётного периода, статичная или относительная, смотрите пример кода ниже dimensions - Список полей-группировок, актуальный список полей доступен по ссылке metrics - Список полей-метрик, актуальный список полей доступен по ссылке samplingLevel - Уровень семплирования, рекомендуемое значение “HIGHER_PRECISION” token - Объект созданный с помощью функции authorize хранящий учётный данные Пример # Multi-Channel Funnels API my_mcf_data &lt;- RGA::get_mcf(profileId = &quot;ga:170507937&quot;, start.date = &quot;14daysAgo&quot;, end.date = &quot;yesterday&quot;, dimensions = &quot;mcf:conversionDate, mcf:mediumPath&quot;, metrics = &quot;mcf:assistedConversions&quot;, samplingLevel = &quot;HIGHER_PRECISION&quot;, token = alsey.netpeak) 6.7.6 Работа с Real time reporting API Функция get_realtime позволяет вам получить данные из Real time reporting API. Аргументы profileId - Id представления Google Analytics dimensions - Список полей-группировок, актуальный список полей доступен по metrics - Список полей-группировок, актуальный список полей доступен по sort - Список полей полей для сортировки данных token - Объект созданный с помощью функции authorize хранящий учётный данные Пример my_real_time_API &lt;- RGA::get_realtime(profileId = &quot;ga:6056790&quot;, dimensions = &quot;rt:source, rt:medium, rt:country&quot;, metrics = &quot;rt:activeUsers&quot;, sort = &quot;-rt:activeUsers&quot;, token = alsey.netpeak) 6.8 Загрузка данных из API Яндекс Метрики, Yandex Metrica Для работы с API интерфейсами яндекс метрики мной был разработа пакет rym. Для установки пакета используйте команду devtools::install_github(&quot;selesnow/rym&quot;). Для взаимодействия с Яндекс Метрикой существуют следующие API интерфейсы: API управления - Позволяет вам получить информацию о таких объектах как счётчики, цели, фильтры, сегменты и доступы к счётчику. API отчётов - Позволяет получать информацию о статистике посещений сайта и другие данные, не используя интерфейс Яндекс.Метрики. API, совместимым с Google Analytics Core Reporting API (v3) - Позволяет получать информацию о посещаемости сайта и другие данные используя привычные параметры запросов при сборе статистики, если ранее вы работали с Google Analytics Core Reporting API (v3). Logs API - позволяет получать неагрегированные данные, собираемые Яндекс.Метрикой. 6.8.1 Авторизация для работы с API Яндекс Метрики Для авторизации можно использовать функцию rym_auth, но в целом процесс авторизации устроен так же как и в пакетах rmytarget и ryandexdirect, т.е. нет еобходимосьт отдельно запускать функцию для прохождния авторизации, при запуске любой из функций доступных в rym будет запущен процесс поиска файла в котором хранятся учётные данные и если такой файл не будет найден то откроется браузер для прохождения авторизации, и полученные учётные данные будут сохранены в файл, в папке которую вы указываете в аргументе token.path. В ходе одной R сессии вы можете авторизоваться и работать под разными пользователями Яндекс Метрики, при этом для каждого пользователя будет создан отдельный файл в котором будут хранится его учётные данные для работы с API Яндекс Метрики. rym_auth(login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) rym_auth(login = &quot;selesnow&quot;, token.path = &quot;metrica_token&quot;) 6.8.2 Функции для работы с API управления Яндекс Метрики rym_get_counters - Загрузка доступных для пользователя счётчиков Яндекс Метрики rym_get_goals - Загрузка списка целей rym_get_filters - Загрузка списка фильтров rym_get_segments - Загрузка списка настроенных сегментов rym_users_grants - Загрузка списка пользователей у которых есть доступ к счётчики с уровнем досупа Основные аргументы функций API управления counter - Номер счётчика Яндекс Метрики login - Логин пользователя Яндекс Метрики token.path - Путь к папке в которой хранятся файлы с учётными данными Пример # API Управления # получить список счётчиков selesnow.counters &lt;- rym_get_counters(login = &quot;selesnow&quot;, token.path = &quot;metrica_token&quot;) vipman.counters &lt;- rym_get_counters(login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) # получить список целей my_goals &lt;- rym_get_goals(counter = 10595804, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) # получить список фильров my_filter &lt;- rym_get_filters(counter = 10595804, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) # получить список сегментов my_segments &lt;- rym_get_segments(counter = 10595804, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) # получить список пользователей счётчика users &lt;- rym_users_grants(counter = 10595804, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) 6.8.3 Загрузка данных из API отчётов Яндекс Метрики Для загрузки данных из API отчётов необходимо использовать функцию rym_get_data. Аргументы counters - Id счётчиков из коорых вы хотите получить данные date.from - Начальная дата date.to - Конечная дата dimensions - Список группировок, актуальный список доступных группировок можно найти по ссылке metrics - Список метрик, актуальный список доступных группировок можно найти по ссылке sort - Список полей по которым будет осуществляться сортировка данных login - Логин пользователя Яндекс Метрики token.path - Путь к папке в которой хранятся файлы с учётными данными Пример # API отчётов reporting.api.stat &lt;- rym_get_data(counters = &quot;23660530,10595804&quot;, date.from = &quot;2018-08-01&quot;, date.to = &quot;yesterday&quot;, dimensions = &quot;ym:s:date,ym:s:lastTrafficSource&quot;, metrics = &quot;ym:s:visits,ym:s:pageviews,ym:s:users&quot;, sort = &quot;-ym:s:date&quot;, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;, lang = &quot;en&quot;) 6.8.4 Загрузка данных из Logs API Яндекс Метрики Функция rym_get_logs позволяет вам получить сырые данные из Logs API. Аргументы counter - Id счётчика Яндекс Метрики date.from - Начальная дата date.to - Конечная дата fields - Список полей которые необходимо загрузить, актуальный список доступный полей можно найти по ссылки в зависимости от источника логов, список полей по просмотрам, список полей по визитам. source - Источник логов, visits — визиты. hits — просмотры. login - Логин пользователя Яндекс Метрики token.path - Путь к папке в которой хранятся файлы с учётными данными Пример logs.api.stat &lt;- rym_get_logs(counter = 23660530, date.from = &quot;2018-08-01&quot;, date.to = &quot;2018-08-05&quot;, fields = &quot;ym:s:date, ym:s:lastTrafficSource, ym:s:referer&quot;, source = &quot;visits&quot;, login = &quot;vipman.netpeak&quot;, token.path = &quot;metrica_token&quot;) 6.8.5 Загрузка данных из API Яндекс Метрики совместимого с Core Reporting API Google Analytics Для работы с API Яндекс Метрики совместимым с Core Reporting API Google Analytics стоит использовать функцию rym_get_ga. Аргументы counter - Id счётчика Яндекс Метрики dimensions - Список группировок, актуальные поля для группировки данных вы можете найти в справочнике metrics - Список загружаемых метрик, актуальный справочник метрик можно найти по ссылке start.date - Начальная дата end.date - Конечная дата sort - Поля для сортировки данных login - Логин пользователя Яндекс Метрики token.path - Путь к папке в которой хранятся файлы с учётными данными Пример ga.api.stat &lt;- rym_get_ga(counter = &quot;ga:22584910&quot;, dimensions = &quot;ga:date,ga:source&quot;, metrics = &quot;ga:sessions,ga:users&quot;, start.date = &quot;2018-08-01&quot;, end.date = &quot;2018-08-05&quot;, sort = &quot;-ga:date&quot;, login = &quot;selesnow&quot;, token.path = &quot;metrica_token&quot;) 6.9 Работа с Google Search Console Получить данные о посещаемости и видимости вашего сайта из Google Search Console в R можно с помощью пакета searchConsoleR, устанавливать его необходимо из репозитория на GitHub с помощью команды devtools::install_github(&quot;MarkEdmondson1234/searchConsoleR&quot;). По больщому счёту для работы с Search Console вам достаточно трёх функций: scr_auth - Авторизация list_websites - Загрузка списка сайтов достпуных в Search Console под авторизованным аккаунтом search_analytics - Загрузка статистики по сайту из Google Search Console Пример library(searchConsoleR) library(googleAuthR) # go to work directory setwd(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 9&quot;) # Auth service_token &lt;- scr_auth() # Get Sites web_sites &lt;- list_websites() # Get Stat gsc_stat &lt;- search_analytics(siteURL = &quot;http://selesnow.github.io/&quot;, startDate = &quot;2018-08-01&quot;, endDate = &quot;2018-08-13&quot;, dimensions = c(&quot;date&quot;, &quot;page&quot;, &quot;query&quot;), searchType = &quot;web&quot;, rowLimit = 5000) Аргументы функции search_analytics siteURL - URL сайта по которому вы хотите получить статистику из Google Search Console startDate - Начальная дата endDate - Конечная дата dimensions - Название полей которые вы хотите загрузить, возможные значения: “date”, “country”, “device”, “page”, “query”, “searchAppearance” searchType - ФИльтр по типу поиска: “web”, “image”, “video” dimensionFilterExp - Фильтр, может применяться к любому полю, например (“device==TABLET”, “country~~GBR”) операторы фильтрации: ‘~~’ - содержит ‘==’ - точное соответсвие ‘!~’ - не содержит ‘!=’ - не соответствует 6.9.1 Как обойти ограничение в 5000 строк на 1 запрос При стандартном обращении к API Google Search Console вы можете получить данные не превышающие 5000 строк, но если вы используете какую либо фильтрацию это ограничение не работает, даже если отфильтрованный массив данных содержит более 500 строк. В связи с чем если вы с помощью цикла отфильтруете запрашиваемые данные например по типу устройста, и соберёте потом полученныенные данные в одну таблицу ы обойдёте это ограничение. *Пример коа для обхода ограничения** devices &lt;- c(&quot;DESKTOP&quot;, &quot;MOBILE&quot;, &quot;TABLET&quot;) sc_result &lt;- list() for (dev in devices) { n &lt;- length(sc_result) + 1 sc_result[[n]] &lt;- search_analytics(siteURL = &quot;http://selesnow.github.io/&quot;, startDate = &quot;2018-08-01&quot;, endDate = &quot;2018-08-13&quot;, dimensions = c(&quot;date&quot;, &quot;page&quot;, &quot;query&quot;), dimensionFilterExp = paste0(&quot;device==&quot;, dev), searchType = &quot;web&quot;) } gsc_stat &lt;- dplyr::bind_rows(sc_result) В примере выше мы сначала создаём вектор devices который в качестве элементов содержит названия всех типов устройств. Далее мы создаём пустой объект класса list в который позже будем по очереди добавлять полученные пок аждому типу устройства данные. На следующем шаге мы создаём цикл for, в котором по очереди перебираем каждый элемент из списка devices и подставляем этот элемент в аргумент dimensionFilterExp функции search_analytics. По завершению цикла мы соединяем полученные результаты по каждому типу устройства в один даат фрей gsc_stat с помощью команды dplyr::bind_rows(sc_result). 6.10 Работа с Google Trends Для загрузки данных из Google Trends можно использовать пакет gtrendsR, для его загрузки выполните команду devtools::install_github('PMassicotte/gtrendsR'). Основная функция пакета gtrends bvttn cktle.obt аргументы: keyword - Запросы по которым вы хотите получить динамику колическа поисковых запросов geo - Список стран по которым вам необходимо получить данные gprop - Продукт Google, для которого выполняется запрос тренда, возможные значения: “web”, “news”, “images”, “froogle”, “youtube” time - Период за который вы запрашиваете данные, возможные значения: “now 1-H” - Данные за последний час “now 4-H” - Данные за последние 4 часа “now 1-d” - Данные за последний день “now 7-d” - Данные за последние 7 дней “today 1-m” - Данные за последние 30 дней “today 3-m” - Данные за последние 90 дней “today 12-m” - Данные за последние 12 месяцев “today+5-y” - Данные за последние 5 лет “all” - Данные за всё время, начиная с 2004 года “Y-m-d Y-m-d” - Временной интервал между двумя датами (например: 2010-01-01 2010-04-03) Пример загрузки данных с Google Trends library(gtrendsR) # query res &lt;- gtrends(keyword = c(&quot;google adwords&quot;, &quot;яндекс директ&quot;, &quot;google ads&quot;, &quot;facebook ads&quot;), geo = c(&quot;RU&quot;, &quot;UA&quot;, &quot;KZ&quot;, &quot;BY&quot;), gprop = &quot;web&quot;, time = &quot;2018-04-01 2018-08-01&quot;) После выполнения приведённого выше кода вы получите список res, который будет содержать несколько дата фреймов: interest_by_city - Данные в разбивке по городам interest_by_region - данные в разбивке по регионам interest_over_time - данные с разбивкой по времени Для того, что бы сохранить в качестве отдельного объекта нужные вам данные вы можете воспользоваться следующим кодом. # results by_city &lt;- res$interest_by_city by_region &lt;- res$interest_by_region over_time &lt;- res$interest_over_time 6.10.1 Манипуляция с данными полученными из Google Trends Данные полученные из Google Trends являются неплохим примером для работы с рассмотренным на первом модуле пакете tidyr. # to tidy library(tidyr) library(dplyr) # by keywords tidy_res &lt;- over_time %&gt;% group_by(date, keyword) %&gt;% # grouping summarise(hits = sum(hits)) %&gt;% # aggregate spread(key = keyword , value = hits) # tidying # by country tidy_res_country &lt;- over_time %&gt;% group_by(date, geo) %&gt;% # grouping summarise(hits = sum(hits)) %&gt;% # aggregate spread(key = geo , value = hits) # tidying Выполнив приведённый выше код вы преобразете данные из длинного формата в широкий, и сможете проанализировать динамику изменения каждого поискового запроса в определённый период времени. 6.11 Парсинг веб сайтов, Web scrapping Забегая наперёд скажу, что данный урок (2 модуль, 10 урок) значительно проще понять при просмотре видео, чем при чтении конспекта курса. Итак, наиболее удобный способ сбора данных с веб страниц в R предосталвяет пакет rvest, с помощью его функций вы можете: Собирать информации с веб страниц с помошью css селекторов или xpath локаторов. Взаимодейтсвовать с различными элементами сайта, например отправлять формы. Имитировать пользовательские сессии, начиная от процесса авторизации. 6.11.1 Поиск элементов на веб странице Перед тем как приступить к парсингу HTML страницы е необходимо загрузить в R с помощью команды simpl_html &lt;- read_html(&quot;test_html_page.html&quot;), ’nf эта команда загрузит страницу которую вы можете найти в материалах курса в папаке “Модуль 2/Урок 10/test_html_page.html”, после чего в вашем рабочем окружении будет создан объект содержащий всю информацию из HTML страницы. В качестве аргумента функции можно указывать путь к локальной HTML странице как в приведённом примере, так и URL адрес любой доступной в интернете HTML страницы. HTML разметка тестовой, локальной страницы &lt;h1&gt; Is the test page &lt;/h1&gt; &lt;div class=&quot;simple_text&quot;&gt; &lt;p id=&#39;first_paragraph&#39;&gt; Is a test page for web scrapping by R and R package rvest&lt;/p&gt; &lt;p&gt; For detail you can go to the rvest tutorial by this &lt;a id=&#39;link1&#39; href=&#39;https://stat4701.github.io/edav/2015/04/02/rvest_tutorial/&#39;&gt;link&lt;/a&gt;.&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;photo&quot; title=&#39;ph&#39;&gt; &lt;img src=&quot;https://i.ytimg.com/vi/jyqnbUNEO00/maxresdefault.jpg&quot; width=&quot;500&quot;&gt; &lt;/div&gt; &lt;h2&gt; Simple table for test &lt;/h2&gt; &lt;table class=&#39;tab&#39; id=&#39;t1&#39; border=&quot;1&quot; cellpadding=&quot;5&quot; title=&#39;test_tab&#39;&gt; &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;Value&lt;/td&gt;&lt;td&gt;Age&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Alexey&lt;/td&gt;&lt;td&gt;34&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Nick&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;Denis&lt;/td&gt;&lt;td&gt;38&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;Andrey&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;h2&gt; Total rows in table &lt;/h2&gt; &lt;p id=&#39;last_paragraph&#39; class=&quot;simple_text&quot;&gt; Test table has four rows. &lt;p id=&quot;update_date&quot;&gt;&lt;i&gt;2018-08-15&lt;/i&gt;&lt;/p&gt; Для поиска какого либо конкретного элемента странцинаиболее удобно использовать CSS селекторы. Гораздо проще вам будет разобраться в данной теме если вы имеете хотя бы базовые знания в HTML разметке, на всякий случай приведу несколько определений которые мы будем использовать. HTML тег - элемент языка разметки гипертекста. Текст, содержащийся между начальным и конечным тегом, отображается и размещается в соответствии со свойствами, указанными в начальном теге. Атрибуты - У тега могут быть свойства, называемые атрибутами, дающие дополнительные возможности форматирования текста. Они записываются в виде сочетания: имя атрибута-значения, причём текстовые значения заключаются в кавычки. Атрибут id - Определяет уникальный идентификатор HTML элемента (его значение должно быть уникально для всего HTML документа). Атрибут class - Определяет группу HTML элементов. На самом деле CSS селекторы это тема для отдельного большого курса, но в принципе вы без проблем можете найти какое нибудь видео на youtube или статью для того, чо бы более глубоко с ними ознакомистся, в этой книге я приведу пример наиболее простых и часто используемых селекторов. 6.11.1 update_date - Поиск элемента по его id, в данном случае поиск элемента с id=“update_date” .simple_text - Поиск элемента по его классу, в данном случае поиск элемента с class=“simple_text” [title] - Поиск по наличию атрибута, в данном случае мы выдерем все элементы в тегах которых присутвует атрибут title [title=‘test_tab’] - Поиск элементов по значению атрибута, в данном случае мы выберем элементы в которых атрибут title равен “test_tab” table - Поиск элемента по названия тега, в данном случае мы выберем все элементы которые находятся внутри тега table div p a - Вложенные селекторы, в данном случае мы сначала ищем элемент внутри тега div, далее внутри него ищем элемент находящийся внутри тега p после чего внутри него ищем элемент внутри тега a, далее в примере будет прозе это понять. # Поиск элемента по ID date_node_css_id &lt;- html_nodes(x = simpl_html, css = &quot;#update_date&quot;) # Поиск элемента по классу searh_class &lt;- html_nodes(simpl_html, css = &quot;.simple_text&quot;) # Поиск по наличию атрибута attr_presence &lt;- html_nodes(simpl_html, css = &quot;[title]&quot;) # Поиск по значению атрибута attr_value &lt;- html_nodes(simpl_html, css = &quot;[title=&#39;test_tab&#39;]&quot;) # Поиск по тегу tags &lt;- html_nodes(simpl_html, css = &quot;table&quot;) # Вложенные селекторы many_selectors &lt;- html_nodes(simpl_html, css = &quot;div p a&quot;) 6.11.2 Извлечение значений из полученныз элементов HTML страницы В прошлом примере мы создали 6 новых объектов в рабочем окружении, все эти объекты являются элементами HTML срнацы, далее из этих элементов мы можем получить некоторые значения с помощью функций: html_text - получить текст находящийся внутри элемента html_attrs - получить список атрибутов элемента html_attr - получить значение одного конкретного атриута по его имени html_name - получить имя тега html_table - парсинг таблиц с веб страницы # извлечение текста txt_date &lt;- html_text(date_node_css_id) # извлечение атрибутов txt_attr &lt;- html_attrs(searh_class) # извлечение значения конкретного атрибута txt_attr_val &lt;- html_attr(searh_class[[2]], name = &quot;id&quot;) links_url &lt;- html_nodes(simpl_html, css = &quot;a&quot;) %&gt;% html_attr(name = &quot;href&quot;) links_text &lt;- html_nodes(simpl_html, css = &quot;a&quot;) %&gt;% html_text() # названия тегов tag_names_txt &lt;- html_name(searh_class) # парсинг таблиц my_table &lt;- html_nodes(simpl_html, css = &quot;table&quot;) %&gt;% html_table(header = TRUE) my_tab &lt;- my_table[[1]] 6.11.3 Имитация пользовательской веб сессии Так же с помощью пакета rvest можно имитировать пользовательские сессии, в этом вам помогут следующие фукнции. html_session - Начать пользовательскую сессию jump_to - Перейти по ссылке follow_link - Найти ссылку по её тексту и перейти по этой ссылке back - Вернутся на предыдущую посещённую страницу в ходе сессии html_form - Получить все формы на странице set_values - Заполнить поля формы submit_form - Отправить форму session_history - Посмотреть всю историю сессии Пример имитации пользовательской сессии на сайте rutracker.org library(rvest) # Создаём сессию session &lt;- html_session(&quot;http://rutracker.org/forum/index.php&quot;) # Получаем форму для аутентификации пользователя all_form &lt;- html_form(session) login_form &lt;- html_nodes(session, css = &quot;#login-form-quick&quot;) %&gt;% html_form() %&gt;% .[[1]] # Заполняем форму filled_form &lt;- set_values(login_form, &quot;login_username&quot; = &quot;ваш_логин&quot;, &quot;login_password&quot; = &quot;ваш_пароль&quot;) # Отправляем её submit_form(session, filled_form) # Переходим на главную страницу сайта main &lt;- jump_to(session, &quot;http://rutracker.org/forum/index.php&quot;) username &lt;- html_nodes(main, &quot;.logged-in-as-uname&quot;) %&gt;% html_text() prof_link &lt;- html_nodes(main, &quot;.logged-in-as-uname&quot;) %&gt;% html_attr(&quot;href&quot;) prof &lt;- jump_to(session, prof_link) my_stag_hours &lt;- html_nodes(prof,&#39;table[class=&quot;user_details borderless w100&quot;] b&#39;) %&gt;% .[3] %&gt;% html_text() df &lt;- data.frame(username = username, stag = my_stag_hours) tabl &lt;- html_nodes(prof,&#39;table[class=&quot;user_details borderless w100&quot;]&#39;) %&gt;% html_table() tabl &lt;- data.frame(tabl) # список ссылок html_nodes(prof, &quot;a&quot;) %&gt;% html_text() rules &lt;- follow_link(session, &quot;Правила&quot;) html_nodes(rules, &quot;.post_body&quot;) %&gt;% html_text() session_history(session) Первое что мы делаем это создаём с помощью команды html_session(&quot;http://rutracker.org/forum/index.php&quot;) веб сессию на сайте http://rutracker.org и создаём новый объект session. Далее мы с помощью функции html_form(session) получаем все формы со страницы. Но нам нужна форма Id которой login-form-quick, поэтому мы получаем этот элеент, далее считываем форму и получаем первый элемент из листа хранещего формы. login_form &lt;- html_nodes(session, css = &quot;#login-form-quick&quot;) %&gt;% html_form() %&gt;% .[[1]]. Теперь нам надо заполнить форму, т.е. ввести свой логин и пароль. filled_form &lt;- set_values(login_form, &quot;login_username&quot; = &quot;ваш_логин&quot;, &quot;login_password&quot; = &quot;ваш_пароль&quot;) И отправляем заполненную форму с помощью submit_form(session, filled_form). Далее мы переходим на главную страницу main &lt;- jump_to(session, &quot;http://rutracker.org/forum/index.php&quot;) и для того что бы убедиться что мы уже авторизовались считаем имя пользователя, и заодно ссылку на переход в профиль пользователя. username &lt;- html_nodes(main, &quot;.logged-in-as-uname&quot;) %&gt;% html_text() prof_link &lt;- html_nodes(main, &quot;.logged-in-as-uname&quot;) %&gt;% html_attr(&quot;href&quot;) Теперь мы можем перейти в свой профиль по полученной ссылке - prof &lt;- jump_to(session, prof_link). Далее мы можем получить некорую информацию из своего профиля, например свой стаж на rutracker, давайте для этого выполним команду my_stag_hours &lt;- html_nodes(prof,'table[class=&quot;user_details borderless w100&quot;] b') %&gt;% .[3] %&gt;% html_text(). В данном случае мы загрузили элемен который является таблицей (тег table) и имеет класс “user_details borderless w100”, получить тег, класс и любые атрибуты элемента,а так же полный путь css селектора к этому элементу можно прямо в браузере: Получить css селектор в Google Chrome Как вы видите из gif-ки, для того что бы получить css селектор какого либо объекта, вам необходимо в раузере выделить этот объект, нажать правую кнопку мышки и в меню выбрать “Посмотреть код”, после чего откроется окно в котором буден виден HTML код страницы и опять же нажав по нужному элементу в коде правой кнокпой мышив открывшемся менюбудет пункт Copy, и уже в нём вам досупны команды copy selector и copy xPath, с помощью первой команды вы скопируете css селектор, с помощью второй xPath локатор. Из полученных данных о имени пользователя и его стаже можно сформировать дата фрейм. df &lt;- data.frame(username = username, stag = my_stag_hours) Так же мы можем получить таблицу со всей информацией о вашем профиле: tabl &lt;- html_nodes(prof,&#39;table[class=&quot;user_details borderless w100&quot;]&#39;) %&gt;% html_table() tabl &lt;- data.frame(tabl) С помощью команды html_nodes(prof, &quot;a&quot;) %&gt;% html_text() мы можем получить вектор состоящий из текста прикреплённого ко всем ссылкам на текущей странице. К одной из полученных ссылок прикреплён текст “Правила”, которая соответсвенно ведёт на страницу правил, для того что бы перейти по данной ссылке по прикреплённому тексту можно выполнить команду rules &lt;- follow_link(session, &quot;Правила&quot;), а для того что бы получить первое сообщение мообщение со страницы правил можно выполнить следующую команду html_nodes(rules, &quot;.post_body&quot;) %&gt;% html_text(). Текстом довольно сложно раскрыть тему парсинга сайтов, поэтому я всё же рекомендую пройти видео урок. 6.12 отправка HTTP запросов В большинстве случаев для работы с API интерфейсов всех популярных рекламных платформ и систем веб аналитики наверняка вы сможете найти готовое решение в виде пакета функций, но это зачастую кассается зарубежных сервисов, если речь идёт о сервисах популярных в СНГ то готового решения может и не быть, но вы можете обращаться к API интерфейсам таких срвисов с помощью отправки HTTP запросов. Для работы с HTTP запросами наиболее часто используют пакеты httr и RCurl, но лично мне более удобно работать с httr, поэтому мы с вами разберёмся именно с ним. В начале второй части мы уже говорили про HTTP запросы, и про их методы, так вот в пакете httr для каждого метода запроса существует отдельная, одноимённая функция. POST - отправка POST запроса GET - Отправка GET запроса content - Парсинг полученного ответа # отправка GET запроса get_answer &lt;- GET(url = &quot;http://httpbin.org/ip&quot;) # Отправка запроса с заголовками и параметрами get_answer &lt;- GET(&quot;http://httpbin.org/get&quot;, query = list(param1 = &quot;val1&quot;, param2 = &quot;value2&quot;, date_from = &quot;2018-08-10&quot;)) my_params &lt;- content(x = get_answer, as = &quot;parsed&quot;, type = &quot;application/json&quot;)$args # Отпрака POST запроса r &lt;- POST(url = &quot;http://httpbin.org/post&quot;, body = list(a = 1, b = 2, c = 3)) # Request parts url &lt;- &quot;http://httpbin.org/post&quot; body &lt;- list(a = 1, b = 2, c = 3) # Form encoded r &lt;- POST(url, body = body, encode = &quot;form&quot;) # Multipart encoded r &lt;- POST(url, body = body, encode = &quot;multipart&quot;) # JSON encoded r &lt;- POST(url, body = body, encode = &quot;json&quot;) # Send files POST(url, body = upload_file(&quot;mypath.txt&quot;)) POST(url, body = list(x = upload_file(&quot;mypath.txt&quot;))) Основные аргументы функций GET и POST url - URL на который вы будете отправлять HTTP запрос query - GET параметры body - Тело запроса encode - Тип запроса Аргументы функции content x - Объект содержащтй рехультат выполнения запроса, который вы хотите распарсить, т.е. то, что вы получили отправив запрос используя функцию POST или GET. as - Как необходимо извлечь результат запроса, возможные значени raw, text или parsed, как правило используется parsed. type - Тип, или формат в котором был получен результат: Возможные значения text/html text/xml text/csv text/tab-separated-values application/json application/x-www-form-urlencoded image/jpeg image/png Для отправки запроса с заголовками необходимо использовать функцию add_headers. # Отправка запроса с заголовками get_answer &lt;- GET(&quot;http://httpbin.org/get&quot;, config = add_headers(param3 = &quot;my_header_param&quot;, Authorization = &quot;56536251hshndsh7q687y8&quot;)) my_headers &lt;- content(x = get_answer, as = &quot;parsed&quot;, type = &quot;application/json&quot;)$headers "],
["-3-api-.html", "7 Модуль 3: Работа с загруженными из API интерфейсов различных сервисов данными. 7.1 Отправка и чтение данных из Google Таблиц, пакет googlesheets 7.2 Визуализация данных с помощью пакета ggplot2 7.3 Работа с базами данных, DBI - Интерфейс взаимодействия с базами данных 7.4 Отправка почты с помощью R, пакет mailR 7.5 Как настроить запуск R скриптов по рассписанию", " 7 Модуль 3: Работа с загруженными из API интерфейсов различных сервисов данными. 7.1 Отправка и чтение данных из Google Таблиц, пакет googlesheets Первый вариант использования полученных ранее данных, который мы рассмотрим, это передача этих данных в Google Таблицы, для работы с Google Таблицами нам понадобится пакет googlesheets, установит его модно как с CRAN так и с GitHub. CRAN: install.packages(&quot;googlesheets&quot;) GitHub: devtools::install_github(&quot;jennybc/googlesheets&quot;) Основные функции для работы с Google Таблицами gs_auth - Авторизация gs_ws_new - Создание новой Google Таблицы gs_ws_new - Создать новый рабочий лист gs_add_row - Дописать строки в существующую Google Таблицу gs_edit_cells - Изменение значений ячеек gs_key - Получение метаданных из Google ТАблицы gs_read - Загрузка данных из листа Google Таблицы Основные аргументы функций ss - Объект содержащий мета данные Google Таблицы, полученные с помощью функции gs_key ws - Номер или название листа range - диапазон рабочего листа к которому вы будете обращаться input - данные которые необходимо отправить в Google Таблицу title - Название Google таблицы ws_title - Название рабочего листа Пример Представленный ниже код делает следующе: Проходим авторизацию в API Google диска Запрашиваем данные из Google Analytics Создаём новую Google Тбалицу и записываем в неё полученные данные - gs_new(title = &quot;Google Analytics Data&quot;, ws_title = paste0(&quot;GA &quot;, Sys.Date()), input = my_core_data) Запрашиваем данные из API Яндекс Метрики Создаём новый рабочий лист и передаём в него данные полученные из API Яндекс Метрики, с помощью функции gs_ws_new. Запрашиваем более актуальные данные из Яндекс Метрики. Меняем значения на листе на который мы загрузили более старые данные из Яндекс Метрики, с помощью функции gs_edit_cells. С помощью функции gs_read загружаем данные из Google Таблицы обратно в R. # Go to work directory setwd(&quot;D:\\\\Google Диск\\\\R Для маркетинга\\\\Материалы курса\\\\Модуль 3\\\\Урок 1&quot;) # Auth gs_auth() # Get current user gs_user() ############################################ # Create dox with data, write data intodox ############################################ # load data from google analytics # start data loading library(RGA) my_core_data &lt;- RGA::get_ga(profileId = &quot;ga:170507937&quot;, start.date = &quot;7daysAgo&quot;, end.date = &quot;yesterday&quot;, metrics = &quot;ga:users,ga:sessions,ga:bounces&quot;, dimensions = &quot;ga:date,ga:source,ga:medium&quot;, sort = &quot;-ga:date&quot;, filters = &quot;ga:medium!=cpc,ga:source=@g&quot;, segment = &quot;sessions::condition::ga:bounces&gt;0&quot;, samplingLevel = &quot;HIGHER_PRECISION&quot;, token = readRDS(&quot;D:\\\\Google Диск\\\\R Для маркетинга\\\\Материалы курса\\\\Модуль 2\\\\Урок 7\\\\.r.for.marketing@gmail.com-token.rds&quot;)[[1]], fetch.by = &quot;day&quot;) # Create dox with data new_dox_matadata &lt;- gs_new(title = &quot;Google Analytics Data&quot;, ws_title = paste0(&quot;GA &quot;, Sys.Date()), input = my_core_data) gs_browse(new_dox_matadata) ############################################ #load data from Yandex Metrika library(rym) library(getProxy) # liad data reporting.stat &lt;- rym_get_data(counters = &quot;22584910&quot;, date.from = &quot;2018-08-01&quot;, date.to = &quot;yesterday&quot;, dimensions = &quot;ym:s:date,ym:s:lastTrafficSource&quot;, metrics = &quot;ym:s:visits,ym:s:pageviews,ym:s:users&quot;, sort = &quot;-ym:s:date&quot;, login = &quot;selesnow&quot;, token.path = &quot;D:\\\\Google Диск\\\\R Для маркетинга\\\\Материалы курса\\\\Модуль 2\\\\Урок 8\\\\metrica_token&quot;) # add new sheet to dox new_dox_matadata &lt;- gs_ws_new(ss = new_dox_matadata, ws_title = &quot;YM Data&quot;, input = reporting.stat) # Get sheet title gs_ws_ls(new_dox_matadata) reporting.stat.prev &lt;- rym_get_data(counters = &quot;22584910&quot;, date.from = &quot;2018-07-20&quot;, date.to = &quot;2018-07-31&quot;, dimensions = &quot;ym:s:date,ym:s:lastTrafficSource&quot;, metrics = &quot;ym:s:visits,ym:s:pageviews,ym:s:users&quot;, sort = &quot;-ym:s:date&quot;, login = &quot;selesnow&quot;, token.path = &quot;D:\\\\Google Диск\\\\R Для маркетинга\\\\Материалы курса\\\\Модуль 2\\\\Урок 8\\\\metrica_token&quot;) # add new row to sheet new_dox_matadata &lt;- gs_add_row(ss = new_dox_matadata, ws = &quot;YM Data&quot;, input = reporting.stat) # Get new data reporting.stat.new &lt;- rym_get_data(counters = &quot;22584910&quot;, date.from = &quot;8daysAgo&quot;, date.to = &quot;yesterday&quot;, dimensions = &quot;ym:s:date,ym:s:lastTrafficSource&quot;, metrics = &quot;ym:s:visits,ym:s:pageviews,ym:s:users&quot;, sort = &quot;-ym:s:date&quot;, login = &quot;selesnow&quot;, token.path = &quot;D:\\\\Google Диск\\\\R Для маркетинга\\\\Материалы курса\\\\Модуль 2\\\\Урок 8\\\\metrica_token&quot;) # rewrite data gs_edit_cells(ss = new_dox_matadata, ws = &quot;YM Data&quot;, input = reporting.stat.new, anchor = &quot;A1&quot;, trim = T) ############################################ # Read data from google spreadsheet ############################################ # read docx list my_dox &lt;- gs_ls() my_dox$sheet_key # read metadata my_dox_meta &lt;- gs_key(my_dox$sheet_key) # read data my_data &lt;- gs_read(my_dox_meta, ws = &quot;YM Data&quot;) # read cell feed cell_info &lt;- gs_read_cellfeed(my_dox_meta, ws = &quot;YM Data&quot;) 7.2 Визуализация данных с помощью пакета ggplot2 Пакет ggplot2 на данный момент является один из самых популярнов R пакетов, на данный момент он был установлен более 1 млн. раз. Для установки пакета выполните команду install.packages(&quot;ggplot2&quot;). 7.2.1 Быстрый график, функция qplot Функция qplot позволяет вам максимально быстро строить несложные, и при этом достаточно красивые графики. Аргументы функции qplot x - Ось X y - Ось Y data - Дата фрейм в котором хранятся данные для визуализации facets - Формула, которая разобъёт график на подграфики geom - Геометрия, тип графика, так же можно указать вектор и отразить на одном графике несколько геометрий например geom = c(&quot;line&quot;, &quot;point&quot;) позволит вам на одном графике совместить линейный и точечный график xlim, ylim - Лимиты по хначем осей x и y main - Заголовок графика xlab, ylab - Подписи осей Для начала давайте загрузим данные, которое потом и будем визуализировать. Пример работы с функцией qplot library(RGA) ## Please use predefined Credentials only for the testing requests. To obtain your own Credentials see help(authorize). # load data from Google Analytics ga_data &lt;- RGA::get_ga(profileId = &quot;ga:170507937&quot;, start.date = &quot;14daysAgo&quot;, end.date = &quot;yesterday&quot;, metrics = &quot;ga:users,ga:sessions,ga:bounces&quot;, dimensions = &quot;ga:date,ga:source,ga:medium&quot;, samplingLevel = &quot;HIGHER_PRECISION&quot;, token = readRDS(&quot;.r.for.marketing@gmail.com-token.rds&quot;)[[1]]) Пример работы с функцией qplot library(ggplot2) # first plot # prepare data # sessions by date ga_data %&gt;% group_by(date) %&gt;% summarise(sessions = sum(sessions)) %&gt;% qplot(data = ., x = date, y = sessions, geom = c(&quot;line&quot;, &quot;point&quot;), main = &quot;Sessions by date&quot;) # with group ga_data %&gt;% group_by(date, medium) %&gt;% summarise(sessions = sum(sessions)) %&gt;% qplot(data = ., x = date, y = sessions, group = medium, geom = c(&quot;line&quot;, &quot;point&quot;), main = &quot;Sessions by date and medium&quot;, color = medium) # with facets ga_data %&gt;% group_by(date, medium) %&gt;% summarise(sessions = sum(sessions), bounce_rate = sum(bounces) / sessions) %&gt;% qplot(data = ., x = date, y = sessions, group = medium, geom = c(&quot;line&quot;, &quot;point&quot;), main = &quot;Sessions by date and medium&quot;, color = bounce_rate, facets = medium ~ .) # daily sessions from different medium ga_data %&gt;% qplot(data = ., x = medium, y = sessions, geom = c(&quot;boxplot&quot;), fill = medium, main = &quot;Daily sessions by medium&quot;) # bounce rate by medium ga_data %&gt;% group_by(medium) %&gt;% summarise(bounce_rate = sum(bounces) / sum(sessions)) %&gt;% qplot(data = ., x = medium, y = bounce_rate, geom = &quot;col&quot;, fill = bounce_rate, main = &quot;Bounce rate by medium&quot;) # users by date and medium ga_data %&gt;% group_by(date, medium) %&gt;% summarise(users = sum(users)) %&gt;% qplot(data = ., x = date, y = users, group = date, geom = &quot;col&quot;, fill = medium, main = &quot;Users by date and medium&quot;) 7.2.2 Построение графиков наложением слоёв Рассмотренная нами функция qplot позволяет вам быстро создать несложный график, но в целом синтаксис пакета ggplot2 позволяет строить и значительно более сложные графики, реализуется такой подход с помощью большого набора функций, каждая функция и является отдельным слоем, к которому вы можете задавать свои настройки, все слои объединяются в один график с помозью знака +. Первый, основной слой задётся с помощью функции ggplot. Далее мы можем накладывать другие слои с помощью функций семейств: geom - геометрии, типы графиков aes - Функция для задания эстетических настроек слоя scale - шкалы осей x и y theme - изменение внешнего вида любого элемента графика facet - разбивка графика а подграфики Пример построения графиков наложением слоёв В этот раз мы будем визуализировать данные полученные из Logs API Яндекс Метрики. library(getProxy) library(rym) # обход блокировки getProxy(port = &quot;3128&quot;, country = &quot;RU&quot;, supportsHttps = TRUE, action = &quot;start&quot;) # loading data ym_data &lt;- rym_get_logs(counter = &quot;10595804&quot;, date.from = &quot;2018-08-25&quot;, date.to = &quot;2018-09-01&quot;, fields = &quot;ym:s:date, ym:s:pageViews, ym:s:visitDuration, ym:s:regionCity, ym:s:lastTrafficSource, ym:s:deviceCategory&quot;, source = &quot;visits&quot;, login = &quot;vipman.netpeak&quot;) # Отключаемся от прокси getProxy(action = &quot;stop&quot;) Далее мы разберём большое количество примеров работы со слоями Простая визуализация, построение график ящик с усами # vizualize # step_1 - basic ggplot(data = ym_data, aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot() Изменяем лимиты по оси y, таким образом убирая выбросы В первом случае мы задаём лимиты с помощью слоя coord_cartesian, который принимает ектор из двух числовых значений, это минимальное и максимальное допустимое значение, функциия coord_cartesian работает как увеличительное стеклопросто увеличивает указанную вами часть графика, при этом из таблицы данных никакая информация не удаляется. # step_2 - remove outliers # zoom ggplot(data = ym_data, aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot() + coord_cartesian(ylim = c(0, 20)) Теперь мы ограничим значение по оси y с помощью функции ylim, данная функция удаляет из таблицы данных все строки которые выходят за пределы указанных минимального и максимального значения, что повлечёт за собой изменение среднего значения и медианы, и в целом всех квартилей. # remove ggplot(data = ym_data, aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(fill = &quot;blue&quot;) + ylim(0, 20) ## Warning: Removed 5885 rows containing non-finite values (stat_boxplot). Теперь попрбуем изменить цвет ящиков в зависимости от медианного значения количества просмотров, и с помощь функции scale_fill_gradient укажем тчо мы хотим градиентный переход в зависимости от этого значения. # step_3 - color group_by(ym_data, ym.s.lastTrafficSource) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) Следующий шаг - отсортировать переменные оси x в порядке убывания, таким образом что бы первый, самый левый ящие соответсовал каналу с самым высоким медианным значением количества просмотра страниц на сеанс, а самымй правый наоборот соответсвовал каналу в котором наименьшее медианное значение количества просмотра страниц на сеанс, делается это с помощью пересортировки уровней фактора через функции with и reorder. # step_4 - reorder ym_data$ym.s.lastTrafficSource &lt;- with(ym_data, reorder(ym.s.lastTrafficSource, ym.s.pageViews, function(x) -median(x))) group_by(ym_data, ym.s.lastTrafficSource) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) Разбиваем полученные графики на подграфики с помощью функции facet_grid. # step_5 - facet ym_data$device &lt;- vapply(ym_data$ym.s.deviceCategory, FUN = function(x) switch(x, &quot;1&quot; = &quot;десктоп&quot;, &quot;2&quot; = &quot;мобильные телефоны&quot;, &quot;3&quot; = &quot;планшеты&quot;, &quot;4&quot; = &quot;TV&quot;), FUN.VALUE = &quot;character&quot;) group_by(ym_data, ym.s.lastTrafficSource, device) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) + facet_grid(device ~ .) С помощью функции theme изменим ориентацию подписей оси x с горихонтальной на вертикальную, и немного увеличим шрифт. # step_6 - themes group_by(ym_data, ym.s.lastTrafficSource, device) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) + facet_grid(device ~ .) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 12)) Так же мы можем менять общую тему всего графика применяю уже готовые темы с помощью семейства функций theme. group_by(ym_data, ym.s.lastTrafficSource, device) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) + facet_grid(device ~ .) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 12)) + theme_classic() group_by(ym_data, ym.s.lastTrafficSource, device) %&gt;% mutate(m_pageviews = median(ym.s.pageViews)) %&gt;% ggplot(data = ., aes(x = ym.s.lastTrafficSource, y = ym.s.pageViews)) + geom_boxplot(aes(fill = m_pageviews)) + coord_cartesian(ylim = c(0, 20)) + scale_fill_gradient(low = &quot;red&quot;, high = &quot;green&quot;) + facet_grid(device ~ .) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 12)) + theme_dark() Пример использования наложения разу 3ёх слоёв и изменения некоторых настроек каждого слоя в отдеьности. # more layers group_by(ym_data, ym.s.date) %&gt;% summarise(page_pr_sessions = sum(ym.s.pageViews) / n()) %&gt;% ggplot(data = ., aes(x = ym.s.date, y = page_pr_sessions, group = 1)) + geom_line(color = &quot;blue&quot;) + geom_point(color = &quot;red&quot;, size = 3) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 7.3 Работа с базами данных, DBI - Интерфейс взаимодействия с базами данных DBI - это интерфейс взаимодействия с базами данных. Основные функции для работы с базами данных dbConnect - Подключение к базе данных dbWriteTable - Запись таблицы в базу данных dbReadTable - Загрузка таблицы из базы данных dbGetQuery - Получить результат выполнения запроса dbSendQuery - Отправка запроса к базе данных dbFetch - Извлечени еэлементов из набора результатов dbGetInfo - Получить информацию о результате запроса или подключении dbListFields - Получить список полей таблицы dbListTables - Список таблиц базы данных dbExistsTable - Проверка наличия таблицы в базе данны dbRemoveTable - Удаление таблицы из базы данных dbDisconnect - Отсоединение от базы данных 7.3.1 Работа с СУБД MySQL MySQL - это одна из наиболее популярных, бесплатных, клиент-серверных баз данных. Для работы с какой либо базой данных помимо пакета DBI необходимо установить дополнительный пакет, который является драйвером и интерфейсом для работы с какой либо конкретной базой данных, для работы с MySQL моожно установить либо RMySQL либо его более актуальную интерпритацию RMariaDB. Жанные пакеты можно устанавливать из CRAN: install.packages(&quot;RMariaDB&quot;) Следующий скрипт демонстрирует использование всех перечисленных выше функций, в нём мы изначально подключимся к базе данных MySQL, поле чего загрузим некоторые данные из API Facebook, и отправим эи данные в базу данных, после чего продемонстрируем как обратно считать записанные рание данные, и то как работать с другими функциями DBI интерфейса. Пример library(RMariaDB) library(rfacebookstat) # Подключаемя к базе данных con &lt;- dbConnect(drv = MariaDB(), user = &quot;имя пользователя&quot;, password = &quot;пароль&quot;, host = &quot;localhost&quot;, port = &quot;3306&quot;, dbname = &quot;название базы данных&quot;) # Загрузка данных из facebook # более подробно о том как работать с API Facebook написано во второй части load(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 4\\\\fb_token.RData&quot;) my_fb_stats &lt;- fbGetMarketingStat(accounts_id = &quot;act_111111111&quot;, level = &quot;ad&quot;, fields = &quot;account_name,campaign_name,ad_id,impressions,clicks&quot;, breakdowns = &quot;impression_device&quot;, date_start = Sys.Date() - 20, date_stop = Sys.Date() - 11, interval = &quot;day&quot;, access_token = fb_token) # Запись данных в MySQL dbWriteTable(conn = con, value = my_fb_stats, name = &quot;fb_data&quot;, append = TRUE, overwrite = FALSE, row.names = FALSE) # Загрузка таблицы из базы данных mysql_table &lt;- dbReadTable(conn = con, name = &quot;fb_data&quot;) # Загрузка результата выполнения запроса query_table &lt;- dbGetQuery(conn = con, statement = &quot;SELECT impression_device, SUM(clicks) as clicks FROM fb_data GROUP BY impression_device&quot;) query_table_2 &lt;- dbSendQuery(conn = con, statement = &quot;SELECT impression_device, SUM(clicks) as clicks FROM fb_data GROUP BY impression_device&quot;) class(query_table_2) dbGetInfo(query_table_2) # query info query_table_2_data &lt;- dbFetch(res = query_table_2, n = -1) # get data dbGetInfo(query_table_2) # query info dbClearResult(query_table_2) # cleare dbGetInfo(query_table_2) # query info # Загрузка списка полей из таблицы dbListFields(conn = con, &quot;fb_data&quot;) # Загрузка списка таблициз базы данных dbListTables(con) # Проверка наличия таблицы в базе данных dbExistsTable(conn = con, &quot;fb_data&quot;) # Удаление таблицы dbRemoveTable(conn = con, &quot;fb_data&quot;) # Проверка наличия таблицы в базе данных dbListTables(con) # Отключение от базы данных dbDisconnect(con) Функция dbConnect создаёт объект подключения к базе данных, в случае работы с клиент серверными базами данных для подключения вам необходимо будет использовать следующие аргумены: drv - Функция которая является драйвером для работы с базой данных, если мы говорим о пакете RMariaDB то необходимо указать MariaDB(), если вы используете пакет RMySQL то необходимо указать MySQL(). user = Имя пользователя базы данных password = Пароль для подключения к базе данных host = IP адрес сервера базы данных port = Порт, для MySQL стандартным портом является 3306 dbname = Название базы данных к которой вы будете подключаться Далее полученный с помощью функции dbConnect объект вы будете использовать во всех остальных функции для работы с базой данных. Для записи информации в базу данных необходимо использовать dbWriteTable, указав следующие аргументы. conn - Объект подключения value - Данные которые вы хотите записать, как правило это какой либо датафрейм name - Название таблицы в которую будут записаны данные append - Дописывать ли строки если такая таблица уже существует в базе данных overwrite = Перезаписать данные если такая таблица уже существует в базе данных row.names = Записывать ли в базу данных имена строк Все остальные функции пакета имеют интуитивно понятный набор аргументов. 7.3.2 Работа с базой данных PostgreSQL PostgreSQL - Свободная объектно-реляционная система управления базами данных. Для работы с PostgreSQL вам необходимо установить пакет RPostgreSQL - install.packages(&quot;RPostgreSQL&quot;) Никакой разницы между работой с PostgreSQL через DBI нет, вы будете использовать теже функции как и в примере выше при работе с MySQL, единственное отличие это то, что вам при подключении используя функцию dbConnect, в аргумент drv необходимо передать функцию PostgreSQL(). Пример работы с PostgreSQL library(RPostgreSQL) library(rfacebookstat) # connect con &lt;- dbConnect(drv = PostgreSQL(), user = &quot;имя пользоватея БД&quot;, password = &quot;пароль&quot;, host = &quot;IP сервера&quot;, port = &quot;5432&quot;, dbname = &quot;название базы данных&quot;) # check connection dbGetInfo(con) # load data # fb load load(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 4\\\\fb_token.RData&quot;) my_fb_stats &lt;- fbGetMarketingStat(accounts_id = &quot;act_11111111111&quot;, level = &quot;ad&quot;, fields = &quot;campaign_name,ad_id,impressions,clicks&quot;, breakdowns = &quot;impression_device&quot;, date_start = Sys.Date() - 20, date_stop = Sys.Date() - 1, interval = &quot;day&quot;, access_token = fb_token) # send to mysql dbWriteTable(conn = con, value = my_fb_stats, name = &quot;fb_data&quot;, append = TRUE, overwrite = FALSE, row.names = FALSE, field.types = c(campaign_name = &quot;character(300)&quot;, ad_id = &quot;bigint&quot;, impressions = &quot;integer&quot;, clicks = &quot;integer&quot;, date_start = &quot;date&quot;, date_stop = &quot;date&quot;, impression_device = &quot;character(100)&quot;)) # load data from mysql pgsql_table &lt;- dbReadTable(conn = con, name = &quot;fb_data&quot;) # load by sql query query_pgsql &lt;- dbGetQuery(conn = con, statement = &quot;SELECT impression_device, SUM(clicks) as clicks FROM fb_data GROUP BY impression_device&quot;) # fields of table dbListFields(conn = con, &quot;fb_data&quot;) # search table dbListTables(con) dbExistsTable(conn = con, &quot;fb_data&quot;) # drop table dbRemoveTable(conn = con, &quot;fb_data&quot;) # check dbListTables(con) # disconnect dbDisconnect(con) 7.3.3 Работа с базой данных SQLite SQLite — компактная встраиваемая СУБД. Исходный код библиотеки передан в общественное достояние. В 2005 году проект получил награду Google-O’Reilly Open Source Awards. SQLite достаточно удобна для локального хранения данных, база не требует установки, и легко может быть интегрирована в ваши скрипты. Работа с SQLite через DBI интерфейс практически не отличается от рассмотренных ранее примеров с MySQL и PostgreSQL, в данном случае мы будем использовать пакет RSQLite и при использовании функции dbConnect для подключения к SQLite вам достаочно всего лишь указать в аргумент drv функцию SQLite() и в качестве второго аргемента указать название базы данных которую вы будете использовать, база даннх является локальным файлом с расширением .db, если указанная база данных не была найдена в рабочей директории она будет создана автоматически. Пример кода для работы с SQLite # go to wd setwd(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 3\\\\Урок 3&quot;) # connection or create base con &lt;- dbConnect(drv = SQLite(), &quot;r_cource_test_base.db&quot;) # fb load load(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 4\\\\fb_token.RData&quot;) my_fb_stats &lt;- fbGetMarketingStat(accounts_id = &quot;act_262115113&quot;, level = &quot;ad&quot;, fields = &quot;campaign_name,ad_id,impressions,clicks&quot;, breakdowns = &quot;impression_device&quot;, date_start = Sys.Date() - 20, date_stop = Sys.Date() - 11, interval = &quot;day&quot;, access_token = fb_token) # send to mysql dbWriteTable(conn = con, value = my_fb_stats, name = &quot;fb_data&quot;, append = FALSE, overwrite = FALSE, row.names = FALSE, field.types = c(campaign_name = &quot;character(300)&quot;, ad_id = &quot;bigint&quot;, impressions = &quot;integer&quot;, clicks = &quot;integer&quot;, date_start = &quot;date&quot;, date_stop = &quot;date&quot;, impression_device = &quot;character(100)&quot;)) # load data from mysql sqlite_table &lt;- dbReadTable(conn = con, name = &quot;fb_data&quot;) # load by sql query query_sqlite &lt;- dbGetQuery(conn = con, statement = &quot;SELECT impression_device, SUM(clicks) as clicks FROM fb_data GROUP BY impression_device&quot;) # fields of table dbListFields(conn = con, &quot;fb_data&quot;) # search table dbListTables(con) dbExistsTable(conn = con, &quot;fb_data&quot;) # drop table dbRemoveTable(conn = con, &quot;fb_data&quot;) # check dbListTables(con) # disconnect dbDisconnect(con) 7.3.4 Работа с облачной базой данных Google BigQuery [Google BigQuery}(https://netpeak.net/ru/blog/google-bigquery-podrobnyy-obzor-funktsii/) - Это облачная база данных с высочайшей скоростью обработки огромных массивов данных. Для работы с Google BigQuery из R необходимо установить пакет bigrquery. Устновка из CRAN: install.packages(&quot;bigrquery&quot;) Установка из GitHub: devtools::install_github(&quot;r-dbi/bigrquery&quot;) В отличае от приведённых выше примеров взаимодействовать с BigQuery из R можно как через DBI интефейс, так и через низкоуровневный API интерфейс. 7.3.4.1 Взаимодействие с Google BigQuery через низкоуровневный API интерфейс Для начала приведу пример кода для загрузки данных из API Facebook, которые мы будем использовать в качестве примера для работы с SQLite. library(rfacebookstat) # fb load load(&quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 2\\\\Урок 4\\\\fb_token.RData&quot;) my_fb_stats &lt;- fbGetMarketingStat(accounts_id = &quot;act_262115113&quot;, level = &quot;ad&quot;, fields = &quot;campaign_name,ad_id,impressions,clicks&quot;, breakdowns = &quot;impression_device&quot;, date_start = Sys.Date() - 20, date_stop = Sys.Date() - 11, interval = &quot;day&quot;, access_token = fb_token) Далее рассмотрим функции для работы с низкоуровневым API интерфейсом Google BigQuery. bq_table - Обращение к таблице bq_dataset - Обращение к набору данных bq_dataset_query - Отправка запроса к набору данных bq_project_query- Отправка запроса к проекту bq_table_upload - Загрузка данных в таблицу bq_table_download - Загрузка таблицы из BigQuery в R bq_table_exists - Проверка наличия таблицы bq_table_fields - Получить список полей таблицы bq_table_delete - Удалить таблицу Основные аргументы project - ID проекта dataset - Название набора данных table - Название таблицы values - Данные которые вы хотите записать в BigQuery create_disposition - Что делать если заданная таблица не найдена в базе, CREATE_IF_NEEDED - создать при необходимости, CREATE_NEVER не создавать таблицу если такой таблицы нет в базе данных write_disposition - Что делать если заданная таблица в которую вы хотите записать данные уже существует в базе: WRITE_APPEND - Дописать новые данные под старыми WRITE_EMPTY - Записать данные только если указанная таблица пустая WRITE_TRUNCATE - Заменить старые данные новыми, перезапись таблицы use_legacy_sql - Использовать в запросе стандартный SQL Диалект Пример работы с низкоуровневым API # write data bq_table(project = &quot;rcourse-215606&quot;, dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_upload(x = ., values = my_fb_stats, create_disposition = &quot;CREATE_IF_NEEDED&quot;, write_disposition = &quot;WRITE_APPEND&quot;) # load table bq_table &lt;- bq_table(project = &quot;rcourse-215606&quot;, dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_download() # load by sql sql_text &lt;- &quot;SELECT impression_device, SUM(clicks) as clicks FROM course_ds.bq_fb GROUP BY impression_device&quot; # project bq_query_p &lt;- bq_project_query(x = &quot;rcourse-215606&quot;, query = sql_text, use_legacy_sql = TRUE) %&gt;% bq_table_download() # dataset sql_text &lt;- &quot;SELECT impression_device, SUM(clicks) as clicks FROM bq_fb GROUP BY impression_device&quot; bq_query_ds &lt;- bq_dataset(project = &quot;rcourse-215606&quot;,dataset = &quot;course_ds&quot;) %&gt;% bq_dataset_query(query = sql_text) %&gt;% bq_table_download() # exist table bq_table(project = &quot;rcourse-215606&quot;,dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_exists() # fields bq_table(project = &quot;rcourse-215606&quot;,dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_fields() # remove table bq_table(project = &quot;rcourse-215606&quot;,dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_delete() bq_table(project = &quot;rcourse-215606&quot;,dataset = &quot;course_ds&quot;, table = &quot;bq_fb&quot;) %&gt;% bq_table_exists() 7.3.4.2 Работа с BigQuery через DBI Опять же разница с прошлыми примерам только в процессе подключения через функцию dbConnect, в качестве аргументов для работы с BigQuery вам необходимо указать drv = bigquery(), а так же передать в агрументы project и dataset, ID проекта и название набора данных соответсвенно. GПример работы через DBI интерфейс # DBI con &lt;- dbConnect(drv = bigquery(), project = &quot;rcourse-215606&quot;, dataset = &quot;course_ds&quot;) # write dbWriteTable(conn = con, name = &quot;bq_fb&quot;, value = my_fb_stats, append = TRUE, overwrite = FALSE, row.names = FALSE) # read bq_table_2 &lt;- dbReadTable(con, &quot;bq_fb&quot;) # read sql bq_sql &lt;- DBI::dbGetQuery(conn = con, statement = &quot;SELECT impression_device, SUM(clicks) as clicks FROM bq_fb GROUP BY impression_device&quot;) # fields of table dbListFields(conn = con, &quot;bq_fb&quot;) # search table dbListTables(con) dbExistsTable(conn = con, &quot;bq_fb&quot;) # drop table dbRemoveTable(conn = con, &quot;bq_fb&quot;) # check dbListTables(con) # disconnect dbDisconnect(con) 7.4 Отправка почты с помощью R, пакет mailR Для отправки писем из R мне встречалось несколько пакетов, наиболее удобным и функциональным мне показался пакет mailR. Работу с этим пакетом я подробно описывал в статье “Как настроить отправку писем с помощью языка R”, в данном конспекте будет так же описаны основные работы с пакетом mailR и htmlTable котрый позволяет переводить данные ваших дата фреймов в HTML формат, и таким образом встраивать в письмо красиво оформленные HTML таблицы. Устновка пакетов: install.packages(&quot;mailR&quot;) install.packages(&quot;htmlTable&quot;) Для отправки писем в пакете mailR есть функция send.mail. Аргументы функции send.mail from - Email адрес отправителя to - Вектор содержащий email адреса получателей subject - Тема письма body - Тело письма encoding - Кодировка текста inline - Логическое выражение, необходимо установить TRUE если вы хотите использовать в письме изображения храненящиеся локально html - Логическое выражение, TRUT если тело письма оформлено в HTML формате smtp - Настройки SMTP сервера, для удобства ссылки на настройки наиболее популярных почтовых сервисов: яндекс, gmail и mail.ru Аргументы для настройки SMTP сервера: host.name - адрес почтового сервера port - порт user.name - имя пользователя для авторизации passwd - пароль для авторизации ssl - использовать или нет ssl шифрование authenticate - Логическая переменная, указывающая, требуется ли авторизация для подключения к SMTP-серверу. send - Логическое значение указывает, следует ли отправлять сообщение по электронной почте в конце функции. attach.files - Путь к файлам которые должны быть прикреплены к письму Для преобразование дата фрейма в таблицу HTML формата необходимо использовать функцию htmlTable из одноимённого пакета, обязательным аргументом данной функции является передача объекта, дата фрейма который вы хотите преобразовать, все остальные аргументы не обязательные и отвечаюют за настройку внешнего вида итоговой HTML таблицы, посмотреть все доступные аргументы вы можете с помощью команды ?htmlTable::htmlTable. В качестве примера я примеду скрипт, который запросит данные из Google Ads, далее с помощью пакета dplyr очистит и преобразует данные к нужному виду. Далее для того, что бы сгруппировать все ключевые слова по уровню показателя качества мы напишем собственную функцию, которая распределит все ключевые слова в одну из трёх групп: low - ключевые слова с показателям качества 1 - 4 балла middle - ключевые слова с показателям качества 5 - 6 баллов high - ключевые слова с показателям качества 7 - 10 баллов После чего с помощью пакета ggplot2 мы сохраним полученные данные в виде графика и с помощью функции htmlTable мы преобразуем полученные из Google Ads данные в формат HTML таблицы. В конце скрипта мы создадим объект msg который будет является телом письма в HTML формате и через функцию send.mail отправим полученное письмо. Пример library(mailR) library(htmlTable) library(RAdwords) library(dplyr) library(ggplot2) library(stringr) # wd setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 3/Урок 4/&quot;) # load data from Google AdWords load(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 2/Урок 2/.google.auth.RData&quot;) body &lt;- statement(select = c(&#39;AdGroupName&#39;, &#39;Id&#39;, &#39;Impressions&#39;, &#39;Clicks&#39;, &#39;Cost&#39;, &#39;Ctr&#39;, &#39;AveragePosition&#39;, &#39;CreativeQualityScore&#39;, &#39;PostClickQualityScore&#39;, &#39;SearchPredictedCtr&#39;, &#39;QualityScore&#39;), report = &quot;KEYWORDS_PERFORMANCE_REPORT&quot;, start = Sys.Date() - 8, end = Sys.Date() - 1) adwordsData &lt;- getData(clientCustomerId = &quot;000-000-0000&quot;, google_auth = google_auth, statement = body) # cleare data adwordsData &lt;- filter(adwordsData, Qualityscore != &quot; --&quot;) %&gt;% mutate(Qualityscore = as.integer(Qualityscore)) # detect QS group ## create fun qs_group_detect &lt;- function (x) { if (x &lt;= 4) { return(&quot;low&quot;) } else if ( between(x, left = 5, right = 6 ) ) { return(&quot;middle&quot;) } else { return(&quot;high&quot;) } } ## detect group for (i in 1:nrow(adwordsData)) { adwordsData$QSGroup[i] &lt;- qs_group_detect(adwordsData$Qualityscore[i]) } # create dashboard ## create table html_table &lt;- select(adwordsData, Adgroup, Impressions, Clicks, Qualityscore) %&gt;% group_by(Adgroup) %&gt;% summarise(Impressions = sum(Impressions), Clicks = sum(Clicks), Qualityscore = median(Qualityscore)) %&gt;% htmlTable(col.rgroup = c(&quot;lightyellow&quot;, &quot;navajowhite&quot;), css.cell = &quot;font-family: Verdana; font-size: 10px&quot;, rnames = FALSE) ## create plots ### reorder afactor adwordsData$QSGroup &lt;- factor(adwordsData$QSGroup, levels = c(&quot;high&quot;, &quot;middle&quot;, &quot;low&quot;)) ### vizualisation qsgroup_plot &lt;- adwordsData %&gt;% ggplot(aes(x = Adgroup)) + geom_bar(aes(fill = QSGroup), position = &quot;fill&quot;) + scale_fill_manual(breaks = c(&quot;high&quot;, &quot;middle&quot;, &quot;low&quot;), values = c(high = &quot;forestgreen&quot;, middle = &quot;tan1&quot; , low = &quot;firebrick1&quot;)) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 8)) + ggtitle(&quot;Distribution keywords by quality score group&quot;) ### save plot to png ggsave(filename = &quot;keyword_group.png&quot;, device = &quot;png&quot;, plot = qsgroup_plot) ## create letter msg &lt;- str_interp(&#39;&lt;body&gt; &lt;h2&gt;Тестовый дайджест отправленный из R&lt;/h2&gt; &lt;p&gt;Этот дайджест сформирован на основе данных полученных из Google Ads.&lt;/p&gt; &lt;br&gt; &lt;h3&gt;Таблица созданная с помощью пакета htmlTable&lt;/h3&gt; ${html_table} &lt;br&gt; &lt;h3&gt;График созданный с помощью пакета ggplot2&lt;/h3&gt; &lt;img src=&quot;keyword_group.png&quot; width=&quot;500&quot;&gt;&lt;/center&gt; &lt;br&gt; &lt;p&gt;Дата формирования дайджеста: ${Sys.Date()}&lt;/p&gt; &lt;/body&gt;&#39;) # send letter # before send browseURL(&quot;https://myaccount.google.com/lesssecureapps&quot;) send.mail(from = &quot;email отправителя&quot;, to = &quot;email получателя&quot;, subject = &quot;Тема письма&quot;, body = msg, encoding = &quot;utf-8&quot;, inline = TRUE, html = TRUE, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;ваш логин&quot;, passwd = &quot;ваш пароль&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) Более подробно данный скрипт разобран в видео уроке. 7.5 Как настроить запуск R скриптов по рассписанию На данном этупе вы уже получили навыки по программированию на R, сбору данных из API всевозможных сервисов, и тому как вы можете использовать собранные данные, всё что нам осталось разобраться как настроить запуск разработанных скриптов по рассписанию. На самом деле есть 3 варианта настроить расписание запуска скриптов в R. Через плагин в RStudio С помощью функций пакета taskscheduleR Самостоятельно в планировщике задач Windows 7.5.1 Настройка расписание через плагин Это пожалуй самый простой способ настроить рассписание запуска ваших скриптов, для начала необходимо установить пакет taskscheduleR, после чего в интервфейск RStudio вам будет доступен плагин, найти его можно в меню Addins. Плагин в интерфейсе RStudio После чего откроется диалоговое окно в котором вы сможете настроить рассписание запуска любого созданного вами скрипта. Настройка рассписания через плагин 7.5.2 Настройка расписание с помощью функций пакета taskscheduleR taskscheduler_create - Создать задачу taskscheduler_ls - Получить список всех задач taskcheduler_runnow - Запустить выполнение задачи taskscheduler_delete - Удалить задачу Пример library(&quot;taskscheduleR&quot;) script_path &lt;- &quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 3\\\\Урок 5\\\\my_script.R&quot; # create task taskscheduler_create(taskname = &quot;google_ads_daily&quot;, rscript = &quot;C:\\\\r_for_marketing_course\\\\Материалы курса\\\\Модуль 3\\\\Урок 5\\\\my_script.R&quot;, schedule = &quot;DAILY&quot;, starttime = &quot;09:30&quot;, startdate = format(Sys.Date(), &quot;%d.%m.%Y&quot;)) # get task list task &lt;- taskscheduler_ls(fileEncoding = &quot;CP866&quot;) # start task taskcheduler_runnow(taskname = &#39;google_ads_daily&#39;) # delete task taskscheduler_delete(taskname = &quot;google_ads_daily&quot;) 7.5.3 Ручная настройка рассписания через планировщик задач Windows Данный процесс подробно был описан мной в статье “Как настроить запуск R-скрипта по расписанию?”. Процесс ручного создания задачи на запуск R скрипта Прописываем в переменную среды Path, путь к папке bin, которая находится в папке куда вы устновили язык R, как правило путь “C:\\Program Files\\R\\R-3.5.1\\bin”, обычно в пути меняется только номер версии. Создаём bat файл в котором пишем “R CMD BATCH путь к скрипту который надо запустить” После чего открываем планировщик задач, открыть его можно по следующему пути “%windir%\\system32\\taskschd.msc /s” Создаём новую задачу и настраиваем рассписание запуска. "],
["-r-r-sources.html", "8 Полезные, русскоязычные ресурсы по языку R (r sources) 8.1 Группы в социальных сетях, groups 8.2 Telegram каналы и чаты 8.3 Блоги, blogs", " 8 Полезные, русскоязычные ресурсы по языку R (r sources) В завершении конспекта предтавляю вам список русскоязычных ресурсов, в которым можете найти дополнтельную информацию и попросить помощи в решении своей задачи: 8.1 Группы в социальных сетях, groups Язык программирования R для статистических вычислений - Группа в Вконтакте, численностью более 3500 человек, тут вы можете попросить помощи, следить за новостями в мире языка R. DataClub - Моя группа Вконтакте, тут вы можете следить за всеми новостями которые кассаются разработанных мной пакетов. Анализ и визуализация данных - Группа Сергея Мастицкого в Facebook. 8.2 Telegram каналы и чаты R4marketing - Мой канал в телеграмм, посвящён применению языка R в решение задач интернет - маркетинга. Язык программирования R, статистика и машинное обучение/data mining - Чат в телеграмме, посвящённый языку R, на данный момент в чате состит немного менее 500 человек, тем не менее там достаточно живое общение, и опять же вы без проблем можете просить там помощи. 8.3 Блоги, blogs r-bloggers - Пожалуй самый крупный и популярный в мире ресурс среди пользователей языка R. r-analytics.blogspot.com - Блог Сергея Мастицкого. habr.com - Публикации по языку R на хабре. alexeyseleznev.wordpress.com - Раздел моего блога посвящённый языку R. "]
]
